% \section{The main package code}
%
% That was the driver, and now the fun starts.
%    \begin{macrocode}
%<@@=fontspec>
%<*fontspec&(xetexx|luatex)>
\ExplSyntaxOn
%    \end{macrocode}
%
% \subsection{Encodings}
%    \begin{macrocode}
\tl_set:Nn \g_fontspec_encoding_tl {TU}
\file_if_exist:nTF {tuenc.def}
  {
    \bool_if:NT \g_@@_euenc_bool
      {
%<xetexx>        \tl_set:Nn \g_fontspec_encoding_tl {EU1}
%<luatex>        \tl_set:Nn \g_fontspec_encoding_tl {EU2}
      }
  }
  {
    \bool_set_true:N \g_@@_euenc_bool
%<xetexx>    \tl_set:Nn \g_fontspec_encoding_tl {EU1}
%<luatex>    \tl_set:Nn \g_fontspec_encoding_tl {EU2}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_if:NT \g_@@_euenc_bool
  {
%<luatex>    \cs_set_eq:NN \fontspec_tmp: \XeTeXpicfile
%<luatex>    \cs_set:Npn \XeTeXpicfile {}
    \RequirePackage{xunicode}
%<luatex>    \cs_set_eq:NN \XeTeXpicfile \fontspec_tmp:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\tl_set:Nn \rmdefault {lmr}
\tl_set:Nn \sfdefault {lmss}
\tl_set:Nn \ttdefault {lmtt}
\RequirePackage[\g_fontspec_encoding_tl]{fontenc}
\tl_set_eq:NN \UTFencname \g_fontspec_encoding_tl % for xunicode if needed
%    \end{macrocode}
% Dealing with a couple of the problems introduced by \pkg{babel}:
%    \begin{macrocode}
\tl_set_eq:NN \cyrillicencoding \g_fontspec_encoding_tl
\tl_set_eq:NN \latinencoding    \g_fontspec_encoding_tl
\AtBeginDocument
 {
  \tl_set_eq:NN \cyrillicencoding \g_fontspec_encoding_tl
  \tl_set_eq:NN \latinencoding    \g_fontspec_encoding_tl
 }
%    \end{macrocode}
% That latin encoding definition is repeated to suppress font warnings.
% Something to do with \cmd\select@language\ ending up in the \texttt{.aux}
% file which is read at the beginning of the document.
%
%
% \subsection{User commands}\label{sec:codeuser}
% This section contains the definitions of the commands detailed in
% the user documentation.  Only the `top level' definitions of the
% commands are contained herein; they all use or define macros which
% are defined or used later on in \vref{sec:codeinternal}.
%
% \subsubsection{Helper macros for argument mangling}
%    \begin{macrocode}
\cs_new:Nn \@@_pass_args:nnn
 {
  \IfNoValueTF {#2}
   { \@@_post_arg:w {#1} {#3} }
   { #1 {#2} {#3} }
 }
\NewDocumentCommand \@@_post_arg:w { m m O{} }
 { #1 {#3} {#2} }
%    \end{macrocode}
%
% \subsubsection{Font selection}
% \begin{macro}{\fontspec}
%   This is the main command of the package that
%   selects fonts with various features. It takes two arguments: the
%   font name and the optional requested features of that
%   font. Then this new font family is selected.
%    \begin{macrocode}
\NewDocumentCommand \fontspec { o m }
 { \@@_pass_args:nnn \@@_fontspec:nn {#1} {#2} }

\cs_new:Nn \@@_fontspec:nn
 {
  \fontspec_set_family:Nnn \f@family {#1} {#2}
  \fontencoding { \l_@@_nfss_enc_tl }
  \selectfont
  \ignorespaces
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\setmainfont}
% \begin{macro}{\setsansfont}
% \begin{macro}{\setmonofont}
%     The following three macros perform equivalent operations setting
%     the default font for a
%     particular family: `roman', sans serif, or typewriter
%     (monospaced). I end them with |\normalfont| so that if they're
%     used in the document, the change registers immediately.
%    \begin{macrocode}
\DeclareDocumentCommand \setmainfont { o m }
 { \@@_pass_args:nnn \@@_setmainfont:nn {#1} {#2} }

\cs_new:Nn \@@_setmainfont:nn
 {
  \fontspec_set_family:Nnn \rmdefault {#1}{#2}
  \normalfont
  \ignorespaces
 }

\DeclareDocumentCommand \setsansfont { o m }
 { \@@_pass_args:nnn \@@_setsansfont:nn {#1} {#2} }

\cs_new:Nn \@@_setsansfont:nn
 {
  \fontspec_set_family:Nnn \sfdefault {#1}{#2}
  \normalfont
  \ignorespaces
 }

\DeclareDocumentCommand \setmonofont { o m }
 { \@@_pass_args:nnn \@@_setmonofont:nn {#1} {#2} }

\cs_new:Nn \@@_setmonofont:nn
 {
  \fontspec_set_family:Nnn \ttdefault {#1}{#2}
  \normalfont
  \ignorespaces
 }
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
%
%
% \begin{macro}{\setromanfont}
% This is the old name for \cs{setmainfont}, retained
% for backwards compatibility.
%    \begin{macrocode}
\cs_set_eq:NN \setromanfont \setmainfont
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\setmathrm}
% \begin{macro}{\setmathsf}
% \begin{macro}{\setboldmathrm}
% \begin{macro}{\setmathtt}
% These commands are analogous to \cmd\setmainfont\ and others,
% but for selecting the font used for \cmd\mathrm, \etc. They
% can only be used in the preamble of the
% document. \cmd\setboldmathrm\ is used for specifying which
% fonts should be used in \cmd\boldmath.
%    \begin{macrocode}
\tl_new:N \g_@@_mathrm_tl
\tl_new:N \g_@@_bfmathrm_tl
\tl_new:N \g_@@_mathsf_tl
\tl_new:N \g_@@_mathtt_tl
\DeclareDocumentCommand \setmathrm { o m }
 { \@@_pass_args:nnn \@@_setmathrm:nn {#1} {#2} }

\cs_new:Nn \@@_setmathrm:nn
 {
  \fontspec_set_family:Nnn \g_@@_mathrm_tl {#1} {#2}
 }

\DeclareDocumentCommand \setboldmathrm { o m }
 { \@@_pass_args:nnn \@@_setboldmathrm:nn {#1} {#2} }

\cs_new:Nn \@@_setboldmathrm:nn
 {
  \fontspec_set_family:Nnn \g_@@_bfmathrm_tl {#1} {#2}
 }

\DeclareDocumentCommand \setmathsf { o m }
 { \@@_pass_args:nnn \@@_setmathsf:nn {#1} {#2} }

\cs_new:Nn \@@_setmathsf:nn
 {
  \fontspec_set_family:Nnn \g_@@_mathsf_tl {#1} {#2}
 }

\DeclareDocumentCommand \setmathtt { o m }
 { \@@_pass_args:nnn \@@_setmathtt:nn {#1} {#2} }

\cs_new:Nn \@@_setmathtt:nn
 {
  \fontspec_set_family:Nnn \g_@@_mathtt_tl {#1} {#2}
 }
\@onlypreamble\setmathrm
\@onlypreamble\setboldmathrm
\@onlypreamble\setmathsf
\@onlypreamble\setmathtt
%    \end{macrocode}
% If the commands above are not executed, then \cmd\rmdefault\ (\etc)
% will be used.
%    \begin{macrocode}
\tl_set:Nn \g_@@_mathrm_tl {\rmdefault}
\tl_set:Nn \g_@@_mathsf_tl {\sfdefault}
\tl_set:Nn \g_@@_mathtt_tl {\ttdefault}
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
% \end{macro}
%
% \begin{macro}{\newfontfamily}
% \begin{macro}{\newfontface}
%   This macro takes the arguments of \cs{fontspec} with a prepended
%   \meta{instance cmd}. This command is used
%   when a specific font instance needs to be referred to repetitively
%   (\eg, in a section heading) since continuously calling
%   \cs{fontspec_select:nn} is inefficient because it must parse the
%   option arguments every time.
%
%   \cs{fontspec_select:nn} defines a font family and saves its name in
%   \cs{l_fontspec_family_tl}. This family is then used in a typical NFSS \cmd\fontfamily\
%   declaration, saved in the macro name specified.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontfamily { m o m }
 { \@@_pass_args:nnn { \@@_newfontfamily:Nnn #1 } {#2} {#3} }

\cs_new:Nn \@@_newfontfamily:Nnn
 {
  \fontspec_set_family:cnn { g_@@_ \cs_to_str:N #1 _family } {#2} {#3}
  \use:x
   {
    \exp_not:N \DeclareRobustCommand \exp_not:N #1
     {
      \exp_not:N \fontfamily { \use:c {g_@@_ \cs_to_str:N #1 _family} }
      \exp_not:N \fontencoding { \l_@@_nfss_enc_tl }
      \exp_not:N \selectfont
     }
   }
 }
%    \end{macrocode}
% \cmd\newfontface\ uses the fact that if the argument to \feat{BoldFont}, etc., is empty (\ie, |BoldFont={}|), then no bold font is searched for.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontface { m o m }
 { \@@_pass_args:nnn { \@@_newfontface:Nnn #1 } {#2} {#3} }

\cs_new:Nn \@@_newfontface:Nnn
 {
  \newfontfamily #1 [ BoldFont={},ItalicFont={},SmallCapsFont={},#2 ] {#3}
 }
%    \end{macrocode}
% \end{macro} \end{macro}
%
% \subsubsection{Font feature selection}
%
% \begin{macro}{\defaultfontfeatures}
%   This macro takes one argument that consists of all of feature
%   options that will be applied by default to all subsequent
%   \cs{fontspec}, et al., commands. It stores its value in
%   \cs{g_fontspec_default_fontopts_tl} (initialised empty), which is
%   concatenated with the individual macro choices in the
%   [...] macro.
%    \begin{macrocode}
\clist_new:N \g_@@_default_fontopts_clist
\prop_new:N \g_@@_fontopts_prop
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \defaultfontfeatures { t+ o m }
 {
  \IfNoValueTF {#2}
   { \@@_set_default_features:nn {#1} {#3} }
   { \@@_set_font_default_features:nnn {#1} {#2} {#3} }
  \ignorespaces
 }
\cs_new:Nn \@@_set_default_features:nn
 {
  \IfBooleanTF {#1} \clist_put_right:Nn \clist_set:Nn
   \g_@@_default_fontopts_clist {#2}
 }
%    \end{macrocode}
% The optional argument specifies a font identifier.
% Branch for either (a)~single token input such as \verb|\rmdefault|, or (b)~otherwise assume its a fontname.
% In that case, strip spaces and file extensions and lower-case to ensure consistency.
%    \begin{macrocode}
\cs_new:Nn \@@_set_font_default_features:nnn
 {
  \clist_map_inline:nn {#2}
   {
    \tl_if_single:nTF {##1}
     { \tl_set:No \l_@@_tmp_tl { \cs:w g_@@_ \cs_to_str:N ##1 _family\cs_end: } }
     { \@@_sanitise_fontname:Nn \l_@@_tmp_tl {##1} }

    \IfBooleanTF {#1}
     {
      \prop_get:NVNF \g_@@_fontopts_prop \l_@@_tmp_tl \l_@@_tmpb_tl
       { \tl_clear:N \l_@@_tmpb_tl }
      \tl_put_right:Nn \l_@@_tmpb_tl {#3,}
      \prop_gput:NVV   \g_@@_fontopts_prop \l_@@_tmp_tl \l_@@_tmpb_tl
     }
     {
      \tl_if_empty:nTF {#3}
       { \prop_gremove:NV \g_@@_fontopts_prop \l_@@_tmp_tl }
       { \prop_put:NVn    \g_@@_fontopts_prop \l_@@_tmp_tl {#3,} }
     }
   }
 }
%    \end{macrocode}
%
% \begin{macro}{\@@_sanitise_fontname:Nn}
% Assigns font name |#2| to token list variable |#1| and strips extension(s) from it in the case of an external font.
% We strip spaces for luatex for consistency with luaotfload, although I'm not sure this is necessary any more.
% At one stage this also lowercased the name, but this step has been removed unless someone can remind me why it was necessary.
%    \begin{macrocode}
\cs_new:Nn \@@_sanitise_fontname:Nn
 {
  \tl_set:Nx #1 {#2}
%<luatex>  \tl_remove_all:Nn #1 {~}
  \clist_map_inline:Nn \l_@@_extensions_clist
   {
     \tl_if_in:NnT #1 {##1}
       {
         \tl_remove_once:Nn #1 {##1}
%         \keys_set:nn {fontspec-preparse-external} { Extension = ##1 }
         \clist_map_break:
       }
   }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\addfontfeatures}
%   In order to be able to extend the feature selection of
%   a given font, two things need to be known: the currently selected
%   features, and the currently selected font. Every time a font
%   family is created, this information is saved inside a control
%   sequence with the name of the font family itself.
%
%   This macro extracts this information, then appends the requested
%   font features to add to the already existing ones, and calls the
%   font again with the top level \cs{fontspec} command.
%
%   The default options are \emph{not} applied (which is why
%   \cs{g_fontspec_default_fontopts_tl} is emptied inside the group; this is allowed
%   as \cmd\l_fontspec_family_tl\ is globally defined in \cmd\fontspec_select:nn), so this
%   means that the only added features to the font are strictly those
%   specified by this command.
%
%   \cs{addfontfeature} is defined as an alias, as I found that I
%   often typed this instead when adding only a single font feature.
%    \begin{macrocode}
\bool_new:N \l_@@_disable_defaults_bool
\DeclareDocumentCommand \addfontfeatures {m}
 {
  \fontspec_if_fontspec_font:TF
   {
    \group_begin:
      \prop_get:cnN {g_@@_ \f@family _prop} {options} \l_@@_options_tl
      \prop_get:cnN {g_@@_ \f@family _prop} {fontname} \l_@@_fontname_tl
      \bool_set_true:N \l_@@_disable_defaults_bool
      \use:x
       {
        \exp_not:N \fontspec_select:nn
          { \l_@@_options_tl , #1 } {\l_@@_fontname_tl}
       }
    \group_end:
    \fontfamily\l_fontspec_family_tl\selectfont
   }
   {
    \@@_warning:nx {addfontfeatures-ignored} {#1}
   }
  \ignorespaces
 }
\cs_set_eq:NN \addfontfeature \addfontfeatures
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Defining new font features}
%
% \begin{macro}{\newfontfeature}
%   \cs{newfontfeature} takes two arguments: the name of the feature
%   tag by which to reference it, and the string that is used to
%   select the font feature.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontfeature {mm}
 {
  \keys_define:nn { fontspec }
   {
    #1 .code:n =
     {
      \@@_update_featstr:n {#2}
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\newAATfeature}
% This command assigns a new AAT feature by its code (|#2|,|#3|) to a new name (|#1|).
% Better than \cmd\newfontfeature\ because it checks if the feature exists in the
% font it's being used for.
%    \begin{macrocode}
\DeclareDocumentCommand \newAATfeature {mmmm}
 {
  \keys_if_exist:nnF { fontspec } {#1}
    { \@@_define_font_feature:n {#1} }
  \keys_if_choice_exist:nnnT {fontspec} {#1} {#2}
    { \@@_warning:nxx {feature-option-overwrite} {#1} {#2} }
  \@@_define_feature_option:nnnnn {#1}{#2}{#3}{#4}{}
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newopentypefeature}
% \begin{macro}{\newICUfeature}
% This command assigns a new OpenType feature by its abbreviation (|#2|) to a new name (|#1|).
% Better than \cmd\newfontfeature\ because it checks if the feature exists in the
% font it's being used for.
%    \begin{macrocode}
\DeclareDocumentCommand \newopentypefeature {mmm}
 {
  \keys_if_exist:nnF { fontspec / options } {#1}
    { \@@_define_font_feature:n {#1} }
  \keys_if_choice_exist:nnnT {fontspec} {#1} {#2}
    { \@@_warning:nxx {feature-option-overwrite} {#1} {#2} }
  \@@_define_feature_option:nnnnn {#1}{#2}{}{}{#3}
 }
\cs_set_eq:NN \newICUfeature \newopentypefeature % deprecated
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\aliasfontfeature}
% \begin{macro}{\aliasfontfeatureoption}
% User commands for renaming font features and font feature options.
%    \begin{macrocode}
\bool_new:N \l_@@_alias_bool
\DeclareDocumentCommand \aliasfontfeature {mm}
 {
  \bool_set_false:N \l_@@_alias_bool

  \clist_map_inline:nn
   { fontspec, fontspec-preparse, fontspec-preparse-external,
     fontspec-preparse-nested, fontspec-renderer }
   {

     \keys_if_exist:nnT {##1} {#1}
      {
        \bool_set_true:N \l_@@_alias_bool
        \@@_alias_font_feature:nnn {##1} {#1} {#2}
      }
   }

  \bool_if:NF \l_@@_alias_bool
    { \@@_warning:nx {rename-feature-not-exist} {#1} }
 }

\cs_set:Nn \@@_alias_font_feature:nnn
  {
    \keys_define:nn {#1}
      { #3 .code:n = { \keys_set:nn {#1} { #2 = {##1} } } }
  }

\DeclareDocumentCommand \aliasfontfeatureoption {mmm}
  { \keys_define:nn { fontspec / #1 } { #3 .meta:n = {#2} } }
%    \end{macrocode}
% \end{macro} \end{macro}
%
% \begin{macro}{\newfontscript}
% Mostly used internally, but also possibly useful for users, to define new OpenType
% `scripts', mapping logical names to OpenType script tags.
% Iterates though the scripts in the selected font to check that it's a valid
% feature choice, and then prepends the (\XeTeX) \cmd\font\ feature string with the appropriate
% script selection tag.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontscript {mm}
 {
  \fontspec_new_script:nn {#1} {#2}
  \fontspec_new_script:nn {#2} {#2}
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\keys_define:nn { fontspec } { Script .choice: }
\cs_new:Nn \fontspec_new_script:nn
 {
  \keys_define:nn { fontspec } { Script / #1 .code:n =
    \fontspec_check_script:nTF {#2}
     {
      \tl_set:Nn \l_fontspec_script_tl {#2}
      \int_set:Nn \l_fontspec_script_int {\l_fontspec_strnum_int}
     }
     {
      \fontspec_check_script:nTF {latn}
       {
        \@@_warning:nx {script-not-exist-latn} {#1}
        \keys_set:nn {fontspec} {Script=Latin}
       }
       {
        \@@_warning:nx {script-not-exist} {#1}
       }
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newfontlanguage}
% Mostly used internally, but also possibly useful for users, to define new OpenType
% `languages', mapping logical names to OpenType language tags.
% Iterates though the languages in the selected font to check that it's a valid
% feature choice, and then prepends the (\XeTeX) \cmd\font\ feature string with the appropriate
% language selection tag.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontlanguage {mm}
 {
  \fontspec_new_lang:nn {#1} {#2}
  \fontspec_new_lang:nn {#2} {#2}
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\keys_define:nn { fontspec } { Language .choice: }
\cs_new:Nn \fontspec_new_lang:nn
 {
  \keys_define:nn { fontspec } { Language / #1 .code:n =
    \fontspec_check_lang:nTF {#2}
     {
      \tl_set:Nn \l_fontspec_lang_tl {#2}
      \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
     }
     {
      \@@_warning:nx {language-not-exist} {#1}
      \keys_set:nn { fontspec } { Language = Default }
     }
  }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareFontsExtensions}
% \texttt{dfont} would never be uppercase, right?
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontsExtensions {m}
 {
  \clist_set:Nn \l_@@_extensions_clist { #1 }
  \tl_remove_all:Nn \l_@@_extensions_clist {~}
 }
\DeclareFontsExtensions{.otf,.ttf,.OTF,.TTF,.ttc,.TTC,.dfont}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Programmer's interface}
%
% These functions are not used directly by fontspec when defining fonts;
% they are designed to be used by other packages who wish to do font-related
% things on top of fontspec itself.
%
% Because I haven't fully explored how these functions will behave in
% practise, I am not giving them user-level names. As it becomes more clear
% which of these should be accessible by document writers, I'll open them up
% a little more.
%
% All functions are defined assuming that the font to be queried is
% currently selected as a fontspec font. (I.e., via \verb|\fontspec| or
% from a \verb|\newfontfamily| macro or from \verb|\setmainfont| and so on.)
%
% \begin{macro}{\fontspec_if_fontspec_font:TF}
% Test whether the currently selected font has been loaded by fontspec.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_fontspec_font: {TF,T,F}
 {
  \cs_if_exist:cTF {g_@@_ \f@family _prop} \prg_return_true: \prg_return_false:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_aat_feature:nnTF}
% Conditional to test if the currently selected font contains the \AAT\
% feature (|#1|,|#2|).
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_aat_feature:nn {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \bool_if:NTF \l_@@_atsui_bool
     {
      \fontspec_make_AAT_feature_string:nnTF {#1}{#2}
        \prg_return_true: \prg_return_false:
     }
     {
      \prg_return_false:
     }
   }
   {
    \prg_return_false:
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_opentype:TF}
% Test whether the currently selected font is an OpenType font.
% Always true for LuaTeX fonts.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_opentype: {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool \prg_return_true: \prg_return_false:
   }
   {
    \prg_return_false:
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nTF}
% Test whether the currently selected font contains the raw OpenType
% feature |#1|. E.g.: |\fontspec_if_feature:nTF {pnum} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_feature:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \prop_get:cnN {g_@@_ \f@family _prop} {script-num} \l_@@_tmp_tl
      \int_set:Nn \l_fontspec_script_int {\l_@@_tmp_tl}

      \prop_get:cnN {g_@@_ \f@family _prop} {lang-num} \l_@@_tmp_tl
      \int_set:Nn \l_fontspec_language_int {\l_@@_tmp_tl}

      \prop_get:cnN {g_@@_ \f@family _prop} {script-tag}  \l_fontspec_script_tl
      \prop_get:cnN {g_@@_ \f@family _prop} {lang-tag}  \l_fontspec_lang_tl

      \fontspec_check_ot_feat:nTF {#1} {\prg_return_true:} {\prg_return_false:}
     }
     {
      \prg_return_false:
     }
   }
   {
    \prg_return_false:
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nnnTF}
% Test whether the currently selected font with raw OpenType script tag |#1| and raw OpenType language tag |#2| contains the raw OpenType feature tag |#3|. E.g.: |\fontspec_if_feature:nTF {latn} {ROM} {pnum} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_feature:nnn {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \fontspec_iv_str_to_num:Nn \l_fontspec_script_int {#1}
      \fontspec_iv_str_to_num:Nn \l_fontspec_language_int {#2}
      \fontspec_check_ot_feat:nTF {#3} \prg_return_true: \prg_return_false:
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_script:nTF}
% Test whether the currently selected font contains the raw OpenType
% script |#1|. E.g.: |\fontspec_if_script:nTF {latn} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_script:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \fontspec_check_script:nTF {#1} \prg_return_true: \prg_return_false:
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#1|. E.g.: |\fontspec_if_language:nTF {ROM} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_language:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \prop_get:cnN {g_@@_ \f@family _prop} {script-num} \l_@@_tmp_tl
      \int_set:Nn \l_fontspec_script_int {\l_@@_tmp_tl}
      \prop_get:cnN {g_@@_ \f@family _prop} {script-tag}  \l_fontspec_script_tl

      \fontspec_check_lang:nTF {#1} \prg_return_true: \prg_return_false:
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nnTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#2| in script |#1|. E.g.: |\fontspec_if_language:nnTF {cyrl} {SRB} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_language:nn {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \tl_set:Nn \l_fontspec_script_tl {#1}
      \fontspec_iv_str_to_num:Nn \l_fontspec_script_int {#1}
      \fontspec_check_lang:nTF {#2} \prg_return_true: \prg_return_false:
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_current_script:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType script tag |#1|.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_current_script:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \prop_get:cnN {g_@@_ \f@family _prop} {script-tag}  \l_@@_tmp_tl
      \str_if_eq:nVTF {#1}  \l_@@_tmp_tl
        {\prg_return_true:} {\prg_return_false:}
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_current_language:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType language tag |#1|.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_current_language:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \prop_get:cnN {g_@@_ \f@family _prop} {lang-tag}  \l_@@_tmp_tl
      \str_if_eq:nVTF {#1} \l_@@_tmp_tl
        {\prg_return_true:} {\prg_return_false:}
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_set_family:Nnn}
% \darg{family}
% \darg{fontspec features}
% \darg{font name}
% Defines a new font family from given \meta{features} and \meta{font},
% and stores the name in the variable \meta{family}.
% See the standard \pkg{fontspec} user commands for applications of this
% function.
%
% We want to store the actual name of the font family within the \meta{family}
% variable because the actual \LaTeX\ family name is automatically generated
% by fontspec and it's easier to keep it that way.
%
% Please use |\fontspec_set_family:Nnn| instead of |\fontspec_select:nn|,
% which may change in the future.
%    \begin{macrocode}
\cs_new:Nn \fontspec_set_family:Nnn
 {
  \tl_set:Nn \l_@@_family_label_tl { #1 }
  \fontspec_select:nn {#2}{#3}
  \tl_set_eq:NN #1 \l_fontspec_family_tl
 }
\cs_generate_variant:Nn \fontspec_set_family:Nnn {c}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_set_fontface:NNnn}
%    \begin{macrocode}
\cs_new:Nn \fontspec_set_fontface:NNnn
 {
  \tl_set:Nn \l_@@_family_label_tl { #1 }
  \fontspec_select:nn {#3}{#4}
  \tl_set_eq:NN #1 \l_fontspec_font
  \tl_set_eq:NN #2 \l_fontspec_family_tl
 }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{expl3 interface for font loading}
%
%    \begin{macrocode}
\cs_set:Nn \@@_fontwrap:n { "#1" }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Npn \@@_primitive_font_set:Nnn #1#2#3
  {
    \font #1 = #2 ~at~ #3 \scan_stop:
  }

\cs_set:Npn \@@_primitive_font_gset:Nnn #1#2#3
  {
    \global \font #1 = #2 ~at~ #3 \scan_stop:
  }

\cs_set:Npn \@@_font_suppress_not_found_error:
  {
    \int_set_eq:NN \xetex_suppressfontnotfounderror:D \c_one
  }

\prg_set_conditional:Nnn \@@_font_if_null:N {p,TF,T,F}
  {
    \ifx #1 \nullfont
      \prg_return_true:
    \else
      \prg_return_false:
    \fi
  }
%    \end{macrocode}
%
%
% \begin{macro}{\fontspec_set:Nnn,\fontspec_gset:Nnn}
% Wrapper around \cs{font_set:Nnn} and \cs{font_gset:Nnn}.
%    \begin{macrocode}
\cs_new:Nn \@@_font_set:Nnn
 {
  \@@_primitive_font_set:Nnn  #1 { \@@_fontwrap:n {#2} } {#3}
 }
\cs_new:Nn \@@_font_gset:Nnn
 {
  \@@_primitive_font_gset:Nnn #1 { \@@_fontwrap:n {#2} } {#3}
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\font_glyph_if_exist:NnTF}
%    \begin{macrocode}
\prg_new_conditional:Nnn \font_glyph_if_exist:Nn {p,TF,T,F}
 {
  \etex_iffontchar:D #1 #2 \scan_stop:
    \prg_return_true:
  \else:
    \prg_return_false:
  \fi:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Internal macros}
% \label{sec:codeinternal}
%
% The macros from here in are used internally by all those defined above.
% They are not designed to remain consistent between versions.
%
%
%
%
% \begin{macro}{\fontspec_select:nn}
% This is the command that defines font families for use, the underlying
% procedure of all \cmd\fontspec-like commands. Given a
% list of font features (|#1|) for a requested font (|#2|),
% it will define an NFSS
% family for that font and put the family name (globally) into \cs{l_fontspec_family_tl}.
% The \TeX\ `\cs{font}' command is (globally) stored in \cs{l_fontspec_font}.
%
% This macro does its processing inside a group to attempt to restrict the scope of its internal processing.
% This works to some degree to insulate the internal commands from having to be manually cleared.
%
% Some often-used variables to know about:
% \begin{itemize}
% \item \cmd{\l_fontspec_fontname_tl} is used as the generic name of the font being defined.
% \item \cmd{\l_@@_fontid_tl} is the unique identifier of the font with all its features.
% \item \cmd{\l_fontspec_fontname_up_tl} is the font specifically to be used as the upright font.
% \item \cmd{\l_@@_basename_tl} is the (immutable) original argument used for |*|-replacing.
% \item \cmd{\l_fontspec_font} is the plain \TeX{} font of the upright font requested.
% \end{itemize}
%    \begin{macrocode}
\cs_set:Nn \fontspec_select:nn
 {
  \group_begin:
  \@@_font_suppress_not_found_error:
  \@@_init:

  \tl_set:Nx \l_fontspec_fontname_tl    {#2}
  \tl_set:Nx \l_fontspec_fontname_up_tl {#2}
  \tl_set:Nx \l_@@_basename_tl          {#2}

  \@@_load_external_fontoptions:Nn \l_fontspec_fontname_tl {#2}
  \@@_extract_all_features:n {#1}
  \@@_preparse_features:

  \@@_load_font:
  \@@_set_scriptlang:
  \@@_get_features:Nn \l_@@_rawfeatures_sclist {}
  \bool_set_false:N \l_@@_firsttime_bool

  \@@_save_family:nTF {#2}
   {
    \@@_save_fontinfo:
    \@@_find_autofonts:
    \DeclareFontFamily{\l_@@_nfss_enc_tl}{\l_fontspec_family_tl}{}
    \@@_set_faces:
    \@@_info:nxx {defining-font} {#1} {#2}
%<*debug>
    \typeout{"\l_@@_fontid_tl"~ defined.}
    \@@_warning:nxx {defining-font} {#1} {#2}
%</debug>
   }
   {
%<*debug>
    \typeout{"\l_@@_fontid_tl"~ already~ defined~ apparently.}
%</debug>
   }
  \group_end:
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_load_external_fontoptions:Nn}
% Load a possible \texttt{.fontspec} font configuration file.
% This file could set font-specific options for the font about to be loaded.
%    \begin{macrocode}
\cs_new:Nn \@@_load_external_fontoptions:Nn
 {
  \@@_sanitise_fontname:Nn #1 {#2}
  \tl_set:Nx \l_@@_ext_filename_tl {#1.fontspec}
  \tl_remove_all:Nn \l_@@_ext_filename_tl {~}
  \prop_if_in:NVF \g_@@_fontopts_prop #1
   {
    \exp_args:No \file_if_exist:nT { \l_@@_ext_filename_tl }
     { \file_input:n { \l_@@_ext_filename_tl } }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_extract_features:}
%    \begin{macrocode}
\cs_new:Nn \@@_extract_all_features:n
 {
  \bool_if:NTF \l_@@_disable_defaults_bool
   {
    \clist_set:Nx \l_@@_all_features_clist {#1}
   }
   {
    \prop_get:NVNF \g_@@_fontopts_prop \l_fontspec_fontname_tl \l_@@_fontopts_clist
     { \clist_clear:N \l_@@_fontopts_clist }

    \prop_get:NVNF \g_@@_fontopts_prop \l_@@_family_label_tl \l_@@_family_fontopts_clist
     { \clist_clear:N \l_@@_family_fontopts_clist }
    \tl_clear:N \l_@@_family_label_tl

    \clist_set:Nx \l_@@_all_features_clist
     {
      \g_@@_default_fontopts_clist,
      \l_@@_family_fontopts_clist,
      \l_@@_fontopts_clist,
      #1
     }
   }
  \tl_set:Nx \l_@@_fontid_tl { \tl_to_str:N \l_fontspec_fontname_tl-:-\tl_to_str:N \l_@@_all_features_clist }
%<*debug>
  \typeout{fontid: \l_@@_fontid_tl}
%</debug>
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_preparse_features:}
% \darg{feature options}
% \darg{font name}
% Perform the (multi-step) feature parsing process.
%
% Convert the requested features to font definition
% strings. First the features are parsed for information about font
% loading (whether it's a named font or external font, etc.), and then
% information is extracted for the names of the other shape fonts.
%    \begin{macrocode}
\cs_new:Nn \@@_preparse_features:
 {
%    \end{macrocode}
% Detect if external fonts are to be used, possibly automatically, and
% parse fontspec features for bold/italic fonts and their features.
%    \begin{macrocode}
  \@@_if_detect_external:VT \l_@@_basename_tl
   { \keys_set:nn {fontspec-preparse-external} {ExternalLocation} }

  \keys_set_known:nxN {fontspec-preparse-external}
   { \l_@@_all_features_clist }
   \l_@@_keys_leftover_clist
%    \end{macrocode}
% When \cmd{\l_fontspec_fontname_tl} is augmented with a prefix or whatever to create
% the name of the upright font (\cmd{\l_fontspec_fontname_up_tl}), this latter is the new `general
% font name' to use.
%    \begin{macrocode}
  \tl_set_eq:NN \l_fontspec_fontname_tl \l_fontspec_fontname_up_tl
  \keys_set_known:nxN {fontspec-renderer} {\l_@@_keys_leftover_clist}
    \l_@@_keys_leftover_clist
  \keys_set_known:nxN {fontspec-preparse} {\l_@@_keys_leftover_clist}
    \l_@@_fontfeat_clist
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_load_font:}
%    \begin{macrocode}
\cs_new:Nn \@@_load_font:
 {
  \@@_font_set:Nnn    \l_fontspec_font
     { \@@_fullname:n {\l_fontspec_fontname_up_tl} } {\f@size pt}
  \@@_font_if_null:NT \l_fontspec_font { \@@_error:nx {font-not-found} {\l_fontspec_fontname_up_tl} }
  \@@_set_font_type:
  \@@_font_gset:Nnn   \l_fontspec_font
     { \@@_fullname:n {\l_fontspec_fontname_up_tl} } {\f@size pt}
  \l_fontspec_font % this is necessary for LuaLaTeX to check the scripts properly
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_if_detect_external:nnT}
% Check if either the fontname ends with a known font extension.
%    \begin{macrocode}
\prg_new_conditional:Nnn \@@_if_detect_external:n {T}
 {
  \clist_map_inline:Nn \l_@@_extensions_clist
   {
    \bool_set_false:N \l_@@_tmpa_bool
    \tl_if_in:nnT {#1 <= end_of_string} {##1 <= end_of_string}
      { \bool_set_true:N \l_@@_tmpa_bool \clist_map_break: }
   }
  \bool_if:NTF \l_@@_tmpa_bool \prg_return_true: \prg_return_false:
 }
\cs_generate_variant:Nn \@@_if_detect_external:nT {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_fullname:n}
% Constructs the complete font name based on a common piece of info.
%    \begin{macrocode}
\cs_set:Nn \@@_fullname:n
 {
  \@@_namewrap:n { #1 \l_@@_extension_tl }
  \l_fontspec_renderer_tl
  \l_@@_optical_size_tl
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_set_scriptlang:}
% Only necessary for OpenType fonts.
% First check if the font supports scripts, then apply defaults if
% none are explicitly requested. Similarly with the language settings.
%    \begin{macrocode}
\cs_new:Nn \@@_set_scriptlang:
 {
  \bool_if:NT \l_@@_firsttime_bool
   {
    \tl_if_empty:NTF \l_@@_script_name_tl
     {
      \fontspec_check_script:nTF {latn}
       {
        \tl_set:Nn \l_@@_script_name_tl {Latin}
        \tl_if_empty:NT \l_@@_lang_name_tl
         {
          \tl_set:Nn \l_@@_lang_name_tl {Default}
         }
        \keys_set:nx {fontspec} {Script=\l_@@_script_name_tl}
        \keys_set:nx {fontspec} {Language=\l_@@_lang_name_tl}
       }
       {
        \@@_info:n {no-scripts}
       }
     }
     {
      \tl_if_empty:NT \l_@@_lang_name_tl
       {
        \tl_set:Nn \l_@@_lang_name_tl {Default}
       }
      \keys_set:nx {fontspec} {Script=\l_@@_script_name_tl}
      \keys_set:nx {fontspec} {Language=\l_@@_lang_name_tl}
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_save_family:nTF}
% Check if the family is unique and, if so, save its information.
% (\cs{addfontfeature} and other macros use this data.)
% Then the font family and its shapes are defined in the NFSS.
%
% Now we have a unique (in fact, too unique!) string that contains
% the family name and every option in abbreviated form. This is used
% with a counter to create a simple NFSS family name for the font we're
% selecting.
%
%    \begin{macrocode}
\prg_new_conditional:Nnn \@@_save_family:n {TF}
 {
%<debug>\typeout{save~ family:~ #1}
  \cs_if_exist:NT \l_@@_nfss_fam_tl
   {
    \cs_set_eq:cN {g_@@_UID_\l_@@_fontid_tl} \l_@@_nfss_fam_tl
   }
  \cs_if_exist:cF {g_@@_UID_\l_@@_fontid_tl}
   {
    % The font name is fully expanded, in case it's defined in terms of macros, before having its spaces zapped:
    \tl_set:Nx \l_@@_tmp_tl {#1}
    \tl_remove_all:Nn \l_@@_tmp_tl {~}

    \cs_if_exist:cTF {g_@@_family_ \l_@@_tmp_tl _int}
     { \int_gincr:c  {g_@@_family_ \l_@@_tmp_tl _int} }
     { \int_new:c    {g_@@_family_ \l_@@_tmp_tl _int} }

    \tl_gset:cx {g_@@_UID_\l_@@_fontid_tl}
     {
      \l_@@_tmp_tl ( \int_use:c {g_@@_family_ \l_@@_tmp_tl _int} )
     }
   }
  \tl_gset:Nv \l_fontspec_family_tl {g_@@_UID_\l_@@_fontid_tl}
  \cs_if_exist:cTF {g_@@_ \l_fontspec_family_tl _prop}
    \prg_return_false: \prg_return_true:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_save_fontinfo:nn}
% Saves the relevant font information for future processing.
%    \begin{macrocode}
\cs_new:Nn \@@_save_fontinfo:
 {
  \prop_new:c {g_@@_ \l_fontspec_family_tl _prop}
  \prop_gput:cnx {g_@@_ \l_fontspec_family_tl _prop} {fontname} { \l_@@_basename_tl }
  \prop_gput:cnx {g_@@_ \l_fontspec_family_tl _prop} {options}  { \l_@@_all_features_clist }
  \prop_gput:cnx {g_@@_ \l_fontspec_family_tl _prop} {fontdef}
   {
    \@@_fullname:n {\l_fontspec_fontname_tl} :
    \l_@@_pre_feat_sclist \l_@@_rawfeatures_sclist
   }
  \prop_gput:cnV {g_@@_ \l_fontspec_family_tl _prop} {script-num} \l_fontspec_script_int
  \prop_gput:cnV {g_@@_ \l_fontspec_family_tl _prop} {lang-num} \l_fontspec_language_int
  \prop_gput:cnV {g_@@_ \l_fontspec_family_tl _prop} {script-tag} \l_fontspec_script_tl
  \prop_gput:cnV {g_@@_ \l_fontspec_family_tl _prop} {lang-tag} \l_fontspec_lang_tl

 }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Setting font shapes in a family}
%
% All NFSS specifications take their default values, so if any of them
% are redefined, the shapes will be selected to fit in with the
% current state. For example, if \cmd\bfdefault\ is redefined to |b|, all
% bold shapes defined by this package will also be assigned to |b|.
%
% The combination shapes are searched first because they use information that may be redefined in the single cases.
% E.g., if no bold font is specified then |set_autofont| will attempt to set it.
% This has subtle/small ramifications on the logic of choosing the bold italic font.
%
% \begin{macro}{\@@_find_autofonts:}
%    \begin{macrocode}
\cs_new:Nn \@@_find_autofonts:
 {
  \bool_if:nF {\l_@@_noit_bool || \l_@@_nobf_bool}
   {
    \@@_set_autofont:Nnn \l_fontspec_fontname_bfit_tl {\l_fontspec_fontname_it_tl} {/B}
    \@@_set_autofont:Nnn \l_fontspec_fontname_bfit_tl {\l_fontspec_fontname_bf_tl} {/I}
    \@@_set_autofont:Nnn \l_fontspec_fontname_bfit_tl {\l_fontspec_fontname_tl} {/BI}
   }

  \bool_if:NF \l_@@_nobf_bool
   {
    \@@_set_autofont:Nnn \l_fontspec_fontname_bf_tl {\l_fontspec_fontname_tl} {/B}
   }

  \bool_if:NF \l_@@_noit_bool
   {
    \@@_set_autofont:Nnn \l_fontspec_fontname_it_tl {\l_fontspec_fontname_tl} {/I}
   }

  \@@_set_autofont:Nnn \l_fontspec_fontname_bfsl_tl {\l_fontspec_fontname_sl_tl} {/B}
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_set_faces:}
%    \begin{macrocode}
\cs_new:Nn \@@_set_faces:
 {
  \@@_add_nfssfont:oooo \mddefault \updefault \l_fontspec_fontname_tl      \l_@@_fontfeat_up_clist
  \@@_add_nfssfont:oooo \bfdefault \updefault \l_fontspec_fontname_bf_tl   \l_@@_fontfeat_bf_clist
  \@@_add_nfssfont:oooo \mddefault \itdefault \l_fontspec_fontname_it_tl   \l_@@_fontfeat_it_clist
  \@@_add_nfssfont:oooo \mddefault \sldefault \l_fontspec_fontname_sl_tl   \l_@@_fontfeat_sl_clist
  \@@_add_nfssfont:oooo \bfdefault \itdefault \l_fontspec_fontname_bfit_tl \l_@@_fontfeat_bfit_clist
  \@@_add_nfssfont:oooo \bfdefault \sldefault \l_fontspec_fontname_bfsl_tl \l_@@_fontfeat_bfsl_clist

  \prop_map_inline:Nn \l_@@_nfssfont_prop { \@@_set_faces_aux:nnnnn ##2 }
 }
\cs_new:Nn \@@_set_faces_aux:nnnnn
 {
  \fontspec_complete_fontname:Nn \l_@@_curr_fontname_tl {#3}
  \@@_make_font_shapes:Nnnnn \l_@@_curr_fontname_tl {#1} {#2} {#4} {#5}
 }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Fonts}
%
% \begin{macro}{\@@_set_font_type:}
% Now check if the font is to be rendered with \ATSUI\ or Harfbuzz. This will either
% be automatic (based on the font type), or specified by the user via a font feature.
%
% This macro sets booleans
% accordingly depending if the font in \cmd\l_fontspec_font\ is an \AAT\
% font or an OpenType font or a font with feature axes (either \AAT\ or
% Multiple Master), respectively.
%    \begin{macrocode}
\cs_new:Nn \@@_set_font_type:
%<*xetexx>
 {
  \bool_set_false:N \l_@@_tfm_bool
  \bool_set_false:N \l_@@_atsui_bool
  \bool_set_false:N \l_@@_ot_bool
  \bool_set_false:N \l_@@_mm_bool
  \bool_set_false:N \l_@@_graphite_bool
  \ifcase\XeTeXfonttype\l_fontspec_font
    \bool_set_true:N \l_@@_tfm_bool
  \or
    \bool_set_true:N \l_@@_atsui_bool
    \ifnum\XeTeXcountvariations\l_fontspec_font > \c_zero
      \bool_set_true:N \l_@@_mm_bool
    \fi
  \or
    \bool_set_true:N \l_@@_ot_bool
  \fi
%    \end{macrocode}
% If automatic, the \cmd{\l_fontspec_renderer_tl} token list will still be
% empty (other suffices that could be added will be later in the feature
% processing), and if it is indeed still empty, assign it a value so that the
% other weights of the font are specifically loaded with the same renderer.
%    \begin{macrocode}
  \tl_if_empty:NT \l_fontspec_renderer_tl
   {
    \bool_if:NTF \l_@@_atsui_bool
     { \tl_set:Nn \l_fontspec_renderer_tl {/AAT} }
     {
       \bool_if:NT \l_@@_ot_bool
        { \tl_set:Nn \l_fontspec_renderer_tl {/OT} }
     }
   }
 }
%</xetexx>
%<*luatex>
 {
  \bool_set_true:N \l_@@_ot_bool
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_set_autofont:Nnn}
% \darg{Font name tl}
% \darg{Base font name}
% \darg{Font name modifier}
%
% This function looks for font with \meta{name} and \meta{modifier} |#2#3|, and if found (i.e., different to font with name |#2|) stores it in tl |#1|. A modifier is something like |/B| to look for a bold font, for example.
%
% We can't match external fonts in this way (in \XeTeX\ anyway; todo: test with LuaTeX).
% If \meta{font name tl} is not empty, then it's already been specified by the user so abort.
% If \meta{Base font name} is not given, we also abort for obvious reasons.
%
% If \meta{font name tl} is empty, then proceed.
% If not found, \meta{font name tl} remains empty.
% Otherwise, we have a match.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_if_empty:nF {x}
\cs_new:Nn \@@_set_autofont:Nnn
 {
  \bool_if:NF \l_@@_external_bool
   {
  \tl_if_empty:xF {#2}
   {
    \tl_if_empty:NT #1
     {
      \@@_if_autofont:nnTF {#2} {#3}
       { \tl_set:Nx #1 {#2#3} }
       { \@@_info:nx {no-font-shape} {#2#3} }
     }
   }
   }
 }

\prg_new_conditional:Nnn \@@_if_autofont:nn {T,TF}
 {
  \@@_font_set:Nnn \l_tmpa_font { \@@_fullname:n {#1}   } {\f@size pt}
  \@@_font_set:Nnn \l_tmpb_font { \@@_fullname:n {#1#2} } {\f@size pt}
  \str_if_eq_x:nnTF { \fontname \l_tmpa_font } { \fontname \l_tmpb_font }
   { \prg_return_false: }
   { \prg_return_true: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_make_font_shapes:Nnnnn}
%  \darg{Font name}
%  \darg{Font series}
%  \darg{Font shape}
%  \darg{Font features}
%  \darg{Size features}
%   This macro eventually uses \cs{DeclareFontShape} to define the font shape in
%   question.
%    \begin{macrocode}
\cs_new:Nn \@@_make_font_shapes:Nnnnn
 {
  \group_begin:
    \keys_set_known:nxN {fontspec-preparse-external} { #4 } \l_@@_leftover_clist
    \@@_load_fontname:n {#1}
    \@@_declare_shape:nnxx {#2} {#3} { \l_@@_fontopts_clist, \l_@@_leftover_clist } {#5}
  \group_end:
 }

\cs_new:Nn \@@_load_fontname:n
 {
    \@@_load_external_fontoptions:Nn \l_fontspec_fontname_tl {#1}
    \prop_get:NVNF \g_@@_fontopts_prop \l_fontspec_fontname_tl \l_@@_fontopts_clist
     { \clist_clear:N \l_@@_fontopts_clist }
    \@@_font_set:Nnn \l_fontspec_font {\@@_fullname:n {\l_fontspec_fontname_tl}} {\f@size pt}
    \@@_font_if_null:NT \l_fontspec_font { \@@_error:nx {font-not-found} {#1} }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_declare_shape:nnnn}
% \darg{Font series}
% \darg{Font shape}
% \darg{Font features}
% \darg{Size features}
% Wrapper for \cmd\DeclareFontShape.
% And finally the actual font shape declaration using \cmd\l_@@_nfss_tl\ defined above.
% \cmd\l_@@_postadjust_tl\ is defined in various places to deal with things like the hyphenation
% character and interword spacing.
%
% The main part is to loop through \feat{SizeFeatures} arguments, which are of the form
% {\par\centering |SizeFeatures={{<one>},{<two>},{<three>}}|.\par}
%    \begin{macrocode}
\cs_new:Nn \@@_declare_shape:nnnn
 {
  \tl_clear:N \l_@@_nfss_tl
  \tl_clear:N \l_@@_nfss_sc_tl
  \tl_set_eq:NN \l_@@_saved_fontname_tl \l_fontspec_fontname_tl

  \exp_args:Nx \clist_map_inline:nn {#4}
   {
    \tl_clear:N \l_@@_size_tl
    \tl_set_eq:NN \l_@@_sizedfont_tl \l_@@_saved_fontname_tl % in case not spec'ed

    \keys_set_known:nxN {fontspec-sizing} { \exp_after:wN \use:n ##1 }
      \l_@@_sizing_leftover_clist
    \tl_if_empty:NT \l_@@_size_tl { \@@_error:n {no-size-info} }

    % "normal"
    \@@_load_fontname:n {\l_@@_sizedfont_tl}
    \@@_setup_nfss:Nnn \l_@@_nfss_tl {#3} {}

    % small caps
    \clist_set_eq:NN \l_@@_fontfeat_curr_clist \l_@@_fontfeat_sc_clist

    \bool_if:NF \l_@@_nosc_bool
     {
      \tl_if_empty:NTF \l_fontspec_fontname_sc_tl
       {
%<debug>      \typeout{Attempting~ small~ caps?}
        \@@_make_smallcaps:TF
         {
%<debug>      \typeout{Small~ caps~ found.}
          \clist_put_left:Nn \l_@@_fontfeat_curr_clist {Letters=SmallCaps}
         }
         {
%<debug>      \typeout{Small~ caps~ not~ found.}
          \bool_set_true:N \l_@@_nosc_bool
         }
       }
       { \@@_load_fontname:n {\l_fontspec_fontname_sc_tl} }% local for each size
     }

    \bool_if:NF \l_@@_nosc_bool
     {
      \@@_setup_nfss:Nnn \l_@@_nfss_sc_tl {#3} {\l_@@_fontfeat_curr_clist}
     }

   }

  \@@_declare_shapes_normal:nn  {#1} {#2}
  \@@_declare_shape_slanted:nn  {#1} {#2}
  \@@_declare_shape_loginfo:nnn {#1} {#2} {#3}
 }
\cs_generate_variant:Nn \@@_declare_shape:nnnn {nnxx}

\cs_new:Nn \@@_setup_nfss:Nnn
 {
  \@@_get_features:Nn \l_@@_rawfeatures_sclist
   { #2 , \l_@@_sizing_leftover_clist , #3 }

  \tl_put_right:Nx #1
   {
    <\l_@@_size_tl> \l_@@_scale_tl
    \@@_fontwrap:n
     {
      \@@_fullname:n { \l_fontspec_fontname_tl }
      : \l_@@_pre_feat_sclist \l_@@_rawfeatures_sclist
     }
   }
 }

\cs_new:Nn \@@_declare_shapes_normal:nn
 {
    \@@_DeclareFontShape:xxxxxx {\l_@@_nfss_enc_tl} {\l_fontspec_family_tl}
      {#1} {#2} {\l_@@_nfss_tl}{\l_@@_postadjust_tl}

    \bool_if:NF \l_@@_nosc_bool
     {
      \@@_DeclareFontShape:xxxxxx {\l_@@_nfss_enc_tl} {\l_fontspec_family_tl}
        {#1}
        {\str_if_eq_x:nnTF {#2} {\itdefault} \sidefault \scdefault}
        {\l_@@_nfss_sc_tl}{\l_@@_postadjust_tl}
     }
 }

\cs_new:Nn \@@_DeclareFontShape:nnnnnn
 {
  \group_begin:
    \normalsize
    \cs_undefine:c {#1/#2/#3/#4/\f@size}
  \group_end:
  \DeclareFontShape{#1}{#2}{#3}{#4}{#5}{#6}
 }
\cs_generate_variant:Nn \@@_DeclareFontShape:nnnnnn {xxxxxx}
%    \end{macrocode}
% This extra stuff for the slanted shape substitution is a little bit awkward.
% We define the slanted shape to be a synonym for it when (a)~we're defining an italic font, but also (b)~when the default slanted shape isn't `it'.
% (Presumably this turned up once in a test and I realised it caused problems. I doubt this would happen much.)
%
% We should test when a slanted font has been specified and not run this code if so, but the \verb|\@@_set_slanted:| code will overwrite this anyway if necessary.
%    \begin{macrocode}
\cs_new:Nn \@@_declare_shape_slanted:nn
 {
  \bool_if:nT
   {
     \str_if_eq_x_p:nn {#2} {\itdefault}  &&
    !(\str_if_eq_x_p:nn {\itdefault} {\sldefault})
   }
   {
    \@@_DeclareFontShape:xxxxxx {\l_@@_nfss_enc_tl}{\l_fontspec_family_tl}{#1}{\sldefault}
      {<->ssub*\l_fontspec_family_tl/#1/\itdefault}{\l_@@_postadjust_tl}
   }
 }
%    \end{macrocode}
% Lastly some informative messaging.
%    \begin{macrocode}
\cs_new:Nn \@@_declare_shape_loginfo:nnn
 {
  \tl_gput_right:Nx \l_fontspec_defined_shapes_tl
   {
    \exp_not:n { \\ \\ }
    *~ '\exp_not:N \str_case:nnF {#1/#2}
     {
       {\mddefault/\updefault} {normal}
       {\bfdefault/\updefault} {bold}
       {\mddefault/\itdefault} {italic}
       {\bfdefault/\itdefault} {bold~ italic}
     } {#2/#3}'~
    with~ NFSS~ spec.: \exp_not:N \\
    \l_@@_nfss_tl
    \exp_not:n { \\ \\ }
    *~ '\exp_not:N \str_case:nnF {#1/\scdefault}
     {
       {\mddefault/\scdefault} {small~ caps}
       {\bfdefault/\scdefault} {bold~ small~ caps}
       {\mddefault/\sidefault} {italic~ small~ caps}
       {\bfdefault/\sidefault} {bold~ italic~ small~ caps}
     } {#2/#3}'~
    with~ NFSS~ spec.: \exp_not:N \\
    \l_@@_nfss_sc_tl
    \tl_if_empty:NF \l_@@_postadjust_tl
     {
      \exp_not:N \\ and~ font~ adjustment~ code: \exp_not:N \\ \l_@@_postadjust_tl
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_@@_pre_feat_sclist}
% These are the features always applied to a font selection before other
% features.
%    \begin{macrocode}
\clist_set:Nn \l_@@_pre_feat_sclist
%<*xetexx>
 {
  \bool_if:NT \l_@@_ot_bool
   {
    \tl_if_empty:NF \l_fontspec_script_tl
     {
      script   = \l_fontspec_script_tl ;
      language = \l_fontspec_lang_tl   ;
     }
   }
 }
%</xetexx>
%<*luatex>
 {
  mode     = \l_fontspec_mode_tl   ;
  \tl_if_empty:NF \l_fontspec_script_tl
   {
    script   = \l_fontspec_script_tl ;
    language = \l_fontspec_lang_tl   ;
   }
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsubsection{Features}
%
% \begin{macro}{\@@_get_features:Nn}
%
%   This macro is a wrapper for |\keys_set:nn| which expands and adds a
%   default specification to the original passed options. It begins by
%   initialising the commands used to hold font-feature specific
%   strings.
%   Its argument is any additional features to prepend to the default.
%    \begin{macrocode}
\cs_set:Nn \@@_get_features:Nn
 {
  \sclist_clear:N \l_@@_rawfeatures_sclist
  \tl_clear:N \l_@@_scale_tl
  \tl_set_eq:NN \l_@@_opacity_tl \g_@@_opacity_tl
  \tl_set_eq:NN \l_@@_hexcol_tl \g_@@_hexcol_tl
  \tl_set_eq:NN \l_@@_postadjust_tl \g_@@_postadjust_tl
  \tl_clear:N \l_@@_wordspace_adjust_tl
  \tl_clear:N \l_@@_punctspace_adjust_tl

  \keys_set_known:nxN {fontspec-renderer} {\l_@@_fontfeat_clist,#2}
    \l_@@_keys_leftover_clist
  \keys_set:nx {fontspec} {\l_@@_keys_leftover_clist}
%    \end{macrocode}
% Finish the colour specification.
% Do not set the colour if not explicitly spec'd else \verb|\color| (using
% specials) will not work.
%    \begin{macrocode}
  \str_if_eq_x:nnF { \l_@@_hexcol_tl \l_@@_opacity_tl }
                   { \g_@@_hexcol_tl \g_@@_opacity_tl }
   {
    \@@_update_featstr:n { color = \l_@@_hexcol_tl\l_@@_opacity_tl }
   }

  \tl_set_eq:NN #1 \l_@@_rawfeatures_sclist
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_init:}
% Initialisations that either need to occur globally:
% (all setting of these variables is done locally inside a group)
%    \begin{macrocode}
\tl_clear:N \l_@@_family_label_tl
\tl_clear:N \l_fontspec_fontname_bf_tl
\tl_clear:N \l_fontspec_fontname_it_tl
\tl_clear:N \l_fontspec_fake_slant_tl
\tl_clear:N \l_fontspec_fake_embolden_tl
\tl_clear:N \l_fontspec_fontname_bfit_tl
\tl_clear:N \l_fontspec_fontname_sl_tl
\tl_clear:N \l_fontspec_fontname_bfsl_tl
\tl_clear:N \l_fontspec_fontname_sc_tl
\tl_clear:N \l_@@_fontfeat_up_clist
\tl_clear:N \l_@@_fontfeat_bf_clist
\tl_clear:N \l_@@_fontfeat_it_clist
\tl_clear:N \l_@@_fontfeat_bfit_clist
\tl_clear:N \l_@@_fontfeat_sl_clist
\tl_clear:N \l_@@_fontfeat_bfsl_clist
\tl_clear:N \l_@@_fontfeat_sc_clist
\tl_clear:N \l_@@_script_name_tl
\tl_clear:N \l_fontspec_script_tl
\tl_clear:N \l_@@_lang_name_tl
\tl_clear:N \l_fontspec_lang_tl
\tl_set:Nn  \g_@@_postadjust_tl { \l_@@_wordspace_adjust_tl \l_@@_punctspace_adjust_tl }

\clist_set:Nn \l_@@_sizefeat_clist {Size={-}}
\tl_new:N  \g_@@_hexcol_tl
\tl_new:N  \g_@@_opacity_tl
\tl_set:Nn \g_@@_hexcol_tl {000000}
\tl_set:Nn \g_@@_opacity_tl {FF~}
%    \end{macrocode}
% Or once per fontspec font invocation:
% (Some of these may be redundant.
% Check whether they're assigned to globally or not.)
%    \begin{macrocode}
\cs_set:Npn \@@_init:
 {
  \bool_set_false:N \l_@@_ot_bool
  \bool_set_true:N \l_@@_firsttime_bool
  \cs_set:Npn \@@_namewrap:n ##1 { ##1 }
  \tl_clear:N \l_@@_optical_size_tl
  \tl_clear:N \l_fontspec_renderer_tl
  \tl_clear:N \l_fontspec_defined_shapes_tl
  \tl_clear:N \g_@@_curr_series_tl
  \tl_gset_eq:NN \l_@@_nfss_enc_tl \g_fontspec_encoding_tl

  % This is for detecting font families when assigning default features.
  % Replace defaults for the standard families because they're not set in the usual way:
  \exp_args:NV \str_case:nnF {\l_@@_family_label_tl}
   {
    {\rmdefault} { \tl_set:Nn \l_@@_family_label_tl {\g_@@_rmfamily_family} }
    {\sfdefault} { \tl_set:Nn \l_@@_family_label_tl {\g_@@_sffamily_family} }
    {\ttdefault} { \tl_set:Nn \l_@@_family_label_tl {\g_@@_ttfamily_family} }
   }{}

%<*luatex>
  \tl_set:Nn \l_fontspec_mode_tl {node}
  \int_set:Nn \luatex_prehyphenchar:D { `\- } % fixme
  \int_zero:N \luatex_posthyphenchar:D        % fixme
  \int_zero:N \luatex_preexhyphenchar:D       % fixme
  \int_zero:N \luatex_postexhyphenchar:D      % fixme
%</luatex>
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_make_smallcaps:TF}
% \label{mac:makesmallcaps}
% This macro checks if the font contains small caps.
%    \begin{macrocode}
\cs_set:Nn \fontspec_make_ot_smallcaps:TF
 {
  \fontspec_check_ot_feat:nTF {+smcp} {#1} {#2}
 }
%<*xetexx>
\cs_set:Nn \@@_make_smallcaps:TF
 {
  \bool_if:NTF \l_@@_ot_bool
   { \fontspec_make_ot_smallcaps:TF {#1} {#2} }
   {
     \bool_if:NT \l_@@_atsui_bool
      { \fontspec_make_AAT_feature_string:nnTF {3}{3} {#1} {#2} }
   }
 }
%</xetexx>
%<*luatex>
\cs_set_eq:NN \@@_make_smallcaps:TF \fontspec_make_ot_smallcaps:TF
%</luatex>
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\sclist_put_right:Nn}
% I'm hardly going to write an `sclist' module but a couple of functions are
% useful. Here, items in semi-colon lists are always followed by a semi-colon
% (as opposed to the s.-c's being placed between elements) so we can append
% sclists without worrying about it.
%    \begin{macrocode}
\cs_set_eq:NN \sclist_clear:N \tl_clear:N
\cs_new:Nn \sclist_gput_right:Nn
 { \tl_gput_right:Nn #1 {#2;} }
\cs_generate_variant:Nn \sclist_gput_right:Nn {Nx}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_update_featstr:n}
% \cmd{\l_@@_rawfeatures_sclist} is the string used to define the list of specific
% font features. Each time another font feature is requested, this
% macro is used to add that feature to the list. Font features are
% separated by semicolons.
%    \begin{macrocode}
\cs_new:Nn \@@_update_featstr:n
 {
  \bool_if:NF \l_@@_firsttime_bool
   {
    \sclist_gput_right:Nx \l_@@_rawfeatures_sclist {#1}
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fontspec_make_feature:nnn}
%   This macro is called by each feature key selected, and runs
%   according to which type of font is selected.
%    \begin{macrocode}
\cs_new:Nn \fontspec_make_feature:nnn
%<*xetexx>
 {
  \bool_if:NTF \l_@@_ot_bool
   { \fontspec_make_OT_feature:n {#3} }
   {
     \bool_if:NT \l_@@_atsui_bool
      { \fontspec_make_AAT_feature:nn {#1}{#2} }
   }
 }
%</xetexx>
%<*luatex>
 { \fontspec_make_OT_feature:n {#3} }
%</luatex>
\cs_generate_variant:Nn \fontspec_make_feature:nnn {nnx}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Nn \fontspec_make_AAT_feature:nn
 {
  \tl_if_empty:nTF {#1}
   { \@@_warning:n {aat-feature-not-exist} }
   {
     \fontspec_make_AAT_feature_string:nnTF {#1}{#2}
      {
       \@@_update_featstr:n {\l_fontspec_feature_string_tl}
     }
     { \@@_warning:nx {aat-feature-not-exist-in-font} {#1,#2} }
   }
 }
\cs_new:Nn \fontspec_make_OT_feature:n
 {
  \tl_if_empty:nTF {#1}
   { \@@_warning:n {icu-feature-not-exist} }
   {
     \fontspec_check_ot_feat:nTF {#1}
      {
       \@@_update_featstr:n {#1}
      }
      { \@@_warning:nx {icu-feature-not-exist-in-font} {#1} }
   }
 }
\cs_new_protected:Nn \fontspec_make_numbered_feature:nn
 {
  \fontspec_check_ot_feat:nTF {#1}
   {
    \@@_update_featstr:n { #1 = #2 }
   }
   { \@@_warning:nx {icu-feature-not-exist-in-font} {#1} }
 }
\cs_generate_variant:Nn \fontspec_make_numbered_feature:nn {xn}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_define_font_feature:n}
% \begin{macro}{\@@_define_feature_option:nnnnn}
% \begin{macro}{\fontspec_define_numbered_feat:nnnn}
% These macros are used in order to simplify font feature definition later on.
%    \begin{macrocode}
\cs_new:Nn \@@_define_font_feature:n
 {
  \keys_define:nn {fontspec} { #1 .multichoice: }
 }
\cs_new:Nn \@@_define_feature_option:nnnnn
 {
  \keys_define:nn {fontspec}
   {
    #1/#2 .code:n = { \fontspec_make_feature:nnn{#3}{#4}{#5} }
   }
 }
\cs_new:Nn \fontspec_define_numbered_feat:nnnn
 {
  \keys_define:nn {fontspec}
   {
    #1/#2 .code:n =
      { \fontspec_make_numbered_feature:nn {#3}{#4} }
   }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fontspec_make_AAT_feature_string:nnTF}
%   This macro takes the numerical codes for a font feature and
%   creates a specified macro containing the string required in the
%   font definition to turn that feature on or off. Used primarily in
%   [...], but also used to check if small caps
%   exists in the requested font (see page~\pageref{mac:makesmallcaps}).
%
% For exclusive selectors, it's easy; just grab the string:
% For \emph{non}-exclusive selectors, it's a little more complex.
% If the selector is even, it corresponds to switching the feature on.
% If the selector is \emph{odd}, it corresponds to switching the feature off.
% But \XeTeX\ doesn't return a selector string for this number, since the
% feature is defined for the `switching on' value. So we need to check the
% selector of the previous number, and then prefix the feature string with |!|
% to denote the switch.
%
% Finally, save out the complete feature string in \cmd\l_fontspec_feature_string_tl.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_make_AAT_feature_string:nn {TF,T,F}
 {
  \tl_set:Nx \l_tmpa_tl { \XeTeXfeaturename \l_fontspec_font #1 }
  \tl_if_empty:NTF \l_tmpa_tl
   { \prg_return_false: }
   {
    \int_compare:nTF { \XeTeXisexclusivefeature\l_fontspec_font #1 > 0 }
     {
      \tl_set:Nx \l_tmpb_tl {\XeTeXselectorname\l_fontspec_font #1\space #2}
     }
     {
      \int_if_even:nTF {#2}
       {
        \tl_set:Nx \l_tmpb_tl {\XeTeXselectorname\l_fontspec_font #1\space #2}
       }
       {
        \tl_set:Nx \l_tmpb_tl
         {
          \XeTeXselectorname\l_fontspec_font #1\space \numexpr#2-1\relax
         }
        \tl_if_empty:NF \l_tmpb_tl { \tl_put_left:Nn \l_tmpb_tl {!} }
       }
    }
    \tl_if_empty:NTF \l_tmpb_tl
     { \prg_return_false: }
     {
      \tl_set:Nx \l_fontspec_feature_string_tl { \l_tmpa_tl = \l_tmpb_tl }
      \prg_return_true:
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_iv_str_to_num:Nn}
% \begin{macro}{\fontspec_v_str_to_num:Nn}
% This macro takes a four character string and converts it to the
% numerical representation required for \XeTeX\ OpenType script/language/feature
% purposes. The output is stored in \cmd\l_fontspec_strnum_int.
%
% The reason it's ugly is because the input can be of the form of any of these:
% `|abcd|', `|abc|', `|abc |', `|ab|', `|ab  |', \etc.
% (It is assumed the first two chars are \emph{always} not spaces.) So this macro
% reads in the string, delimited by a space; this input is padded with \cmd\@empty s
% and anything beyond four chars is snipped. The \cmd\@empty s then are used to reconstruct
% the spaces in the string to number calculation.
%
% The variant \cmd\fontspec_v_str_to_num:n\ is used when looking at features, which are passed around
% with prepended plus and minus signs (\eg, \texttt{+liga}, \texttt{-dlig}); it
% simply strips off the first char of the input before calling the normal \cmd\fontspec_iv_str_to_num:n.
%    \begin{macrocode}
\cs_set:Nn \fontspec_iv_str_to_num:Nn
 {
  \fontspec_iv_str_to_num:w #1 \q_nil #2 \c_empty_tl \c_empty_tl \q_nil
 }
\cs_set:Npn \fontspec_iv_str_to_num:w #1 \q_nil #2#3#4#5#6 \q_nil
 {
  \int_set:Nn #1
   {
      `#2 * "1000000
    + `#3 * "10000
    + \ifx \c_empty_tl #4 32 \else `#4 \fi * "100
    + \ifx \c_empty_tl #5 32 \else `#5 \fi
   }
 }
\cs_generate_variant:Nn \fontspec_iv_str_to_num:Nn {No}
\cs_set:Nn \fontspec_v_str_to_num:Nn
 {
  \bool_if:nTF
   {
    \tl_if_head_eq_charcode_p:nN {#2} {+} ||
    \tl_if_head_eq_charcode_p:nN {#2} {-}
   }
   { \fontspec_iv_str_to_num:No #1 { \use_none:n #2 } }
   { \fontspec_iv_str_to_num:Nn #1 {#2} }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fontspec_check_script:nTF}
% This macro takes an OpenType script tag and checks if it exists in the current
% font. The output boolean is \cmd\@tempswatrue. \cmd\l_fontspec_strnum_int\ is used to store
% the number corresponding to the script tag string.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_check_script:n {TF}
%<*xetexx>
 {
  \fontspec_iv_str_to_num:Nn \l_fontspec_strnum_int {#1}
  \int_set:Nn \l_tmpb_int { \XeTeXOTcountscripts \l_fontspec_font }
  \int_zero:N \l_tmpa_int
  \bool_set_false:N \l__fontspec_check_bool
  \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
   {
    \ifnum \XeTeXOTscripttag\l_fontspec_font \l_tmpa_int = \l_fontspec_strnum_int
      \bool_set_true:N \l__fontspec_check_bool
      \int_set:Nn \l_tmpa_int {\l_tmpb_int}
    \else
      \int_incr:N \l_tmpa_int
    \fi
   }
  \bool_if:NTF \l__fontspec_check_bool \prg_return_true: \prg_return_false:
 }
%</xetexx>
%<*luatex>
 {
  \directlua{fontspec.check_ot_script("l_fontspec_font", "#1")}
  \bool_if:NTF \l__fontspec_check_bool \prg_return_true: \prg_return_false:
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_check_lang:nTF}
% This macro takes an OpenType language tag and checks if it exists in the current
% font/script. The output boolean is \cmd\@tempswatrue. \cmd\l_fontspec_strnum_int\ is used to store
% the number corresponding to the language tag string.
% The script used is whatever's held in \cmd\l_fontspec_script_int. By default, that's the
% number corresponding to `|latn|'.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_check_lang:n {TF}
%<*xetexx>
 {
  \fontspec_iv_str_to_num:Nn \l_fontspec_strnum_int {#1}
  \int_set:Nn \l_tmpb_int
   { \XeTeXOTcountlanguages \l_fontspec_font \l_fontspec_script_int }
  \int_zero:N \l_tmpa_int
  \bool_set_false:N \l__fontspec_check_bool
  \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
   {
    \ifnum\XeTeXOTlanguagetag\l_fontspec_font\l_fontspec_script_int \l_tmpa_int =\l_fontspec_strnum_int
      \bool_set_true:N \l__fontspec_check_bool
      \int_set:Nn \l_tmpa_int {\l_tmpb_int}
    \else
      \int_incr:N \l_tmpa_int
    \fi
   }
  \bool_if:NTF \l__fontspec_check_bool \prg_return_true: \prg_return_false:
 }
%</xetexx>
%<*luatex>
 {
  \directlua
   {
    fontspec.check_ot_lang( "l_fontspec_font", "#1", "\l_fontspec_script_tl" )
   }
  \bool_if:NTF \l__fontspec_check_bool \prg_return_true: \prg_return_false:
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_check_ot_feat:nTF}
% \begin{macro}{\fontspec_check_ot_feat:nT}
% This macro takes an OpenType feature tag and checks if it exists in the current
% font/script/language.
% \cmd\l_fontspec_strnum_int\ is used to store the number corresponding to the feature tag string.
% The script used is whatever's held in \cmd\l_fontspec_script_int. By default, that's the
% number corresponding to `|latn|'. The language used is \cmd\l_fontspec_language_int,
% by default |0|, the `default language'.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_check_ot_feat:n {TF,T}
%<*xetexx>
 {
  \int_set:Nn \l_tmpb_int
   {
    \XeTeXOTcountfeatures \l_fontspec_font
                          \l_fontspec_script_int
                          \l_fontspec_language_int
   }
  \fontspec_v_str_to_num:Nn \l_fontspec_strnum_int {#1}
  \int_zero:N \l_tmpa_int
  \bool_set_false:N \l__fontspec_check_bool
  \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
   {
    \ifnum\XeTeXOTfeaturetag\l_fontspec_font\l_fontspec_script_int\l_fontspec_language_int
         \l_tmpa_int =\l_fontspec_strnum_int
      \bool_set_true:N \l__fontspec_check_bool
      \int_set:Nn \l_tmpa_int {\l_tmpb_int}
    \else
      \int_incr:N \l_tmpa_int
    \fi
   }
  \bool_if:NTF \l__fontspec_check_bool \prg_return_true: \prg_return_false:
 }
%</xetexx>
%<*luatex>
 {
  \directlua
   {
    fontspec.check_ot_feat(
                           "l_fontspec_font", "#1",
                           "\l_fontspec_lang_tl", "\l_fontspec_script_tl"
                          )
   }
  \bool_if:NTF \l__fontspec_check_bool \prg_return_true: \prg_return_false:
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{\pkg{keyval} definitions}
%
% This is the tedious section where we correlate all possible
% (eventually) font feature requests with their \XeTeX\ representations.
%
%    \begin{macrocode}
\cs_new:Nn \@@_keys_define_code:nnn
 {
  \keys_define:nn {#1} { #2 .code:n = {#3} }
 }
%    \end{macrocode}
%
% \subsubsection{Pre-parsing naming information}
%
% These features are extracted from the font feature list before all others.
%
% \paragraph{\feat{ExternalLocation}}
% For fonts that aren't installed in the system. If no argument is given, the font is located
% with |kpsewhich|; it's either in the current directory or the \TeX\ tree. Otherwise, the
% argument given defines the file path of the font.
%    \begin{macrocode}
\bool_new:N \l_@@_external_bool
\@@_keys_define_code:nnn {fontspec-preparse-external} {ExternalLocation}
 {
  \bool_set_true:N \l_@@_nobf_bool
  \bool_set_true:N \l_@@_noit_bool
  \bool_set_true:N \l_@@_external_bool
  \cs_set:Npn \@@_namewrap:n ##1 { [ #1 ##1 ] }
%<*xetexx>
  \keys_set:nn {fontspec-renderer} {Renderer=OpenType}
%</xetexx>
 }
\aliasfontfeature{ExternalLocation}{Path}
%    \end{macrocode}
%
% \paragraph{\feat{Extension}}
% For fonts that aren't installed in the system. Specifies the font extension
% to use.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse-external} {Extension}
 {
  \tl_set:Nn \l_@@_extension_tl {#1}
  \bool_if:NF \l_@@_external_bool
   {
    \keys_set:nn {fontspec-preparse-external} {ExternalLocation}
   }
 }
\tl_clear:N \l_@@_extension_tl
%    \end{macrocode}
%
% \subsubsection{Pre-parsed features}
%
% After the font name(s) have been sorted out, now need to extract any
% renderer/font configuration features that need to be processed before
% all other font features.
%
% \paragraph{\feat{Renderer}}
% This feature must be processed before all others (the other font shape and features options are also pre-parsed for convenience) because the renderer determines the format of the features and even whether certain features are available.
%    \begin{macrocode}
\keys_define:nn {fontspec-renderer}
 {
  Renderer .choices:nn =
   {AAT,ICU,OpenType,Graphite,Full,Basic}
   {
    \int_compare:nTF {\l_keys_choice_int <= 4} {
%<*xetexx>
      \tl_set:Nv \l_fontspec_renderer_tl
        { g_fontspec_renderer_tag_ \l_keys_choice_tl }
%</xetexx>
%<*luatex>
      \@@_warning:nx {only-xetex-feature} {Renderer=AAT/OpenType/Graphite}
%</luatex>
     }
     {
%<*xetexx>
      \@@_warning:nx {only-luatex-feature} {Renderer=Full/Basic}
%</xetexx>
%<*luatex>
      \tl_set:Nv \l_fontspec_mode_tl
        { g_fontspec_mode_tag_ \l_keys_choice_tl }
%</luatex>
     }
   }
 }
\tl_set:cn {g_fontspec_renderer_tag_AAT} {/AAT}
\tl_set:cn {g_fontspec_renderer_tag_ICU} {/OT}
\tl_set:cn {g_fontspec_renderer_tag_OpenType} {/OT}
\tl_set:cn {g_fontspec_renderer_tag_Graphite} {/GR}
\tl_set:cn {g_fontspec_mode_tag_Full}  {node}
\tl_set:cn {g_fontspec_mode_tag_Basic} {base}
%    \end{macrocode}
%
% \paragraph{OpenType script/language}
% See later for the resolutions from \pkg{fontspec} features to OpenType definitions.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {Script}
 {
%<xetexx>    \keys_set:nn {fontspec-renderer} {Renderer=OpenType}
  \tl_set:Nn \l_@@_script_name_tl {#1}
 }
%    \end{macrocode}
% Exactly the same:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {Language}
 {
%<xetexx>    \keys_set:nn {fontspec-renderer} {Renderer=OpenType}
  \tl_set:Nn \l_@@_lang_name_tl {#1}
 }
%    \end{macrocode}
%
% \subsubsection{Bold/italic choosing options}
%
% The \feat{Bold}, \feat{Italic}, and \feat{BoldItalic}
% features are for defining explicitly the bold and italic fonts used
% in a font family.
%
% \paragraph{Bold (NFSS) Series}
% By default, \pkg{fontspec} uses the default bold series, \cs{bfdefault}.
% We want to be able to make this extensible.
%    \begin{macrocode}
\seq_new:N \g_@@_bf_series_seq
\@@_keys_define_code:nnn {fontspec-preparse-external} {BoldSeries}
 {
  \tl_gset:Nx \g_@@_curr_series_tl { #1 }
  \seq_gput_right:Nx \g_@@_bf_series_seq { #1 }
 }
%    \end{macrocode}
%
% \paragraph{Fonts}
% Upright:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse-external} {UprightFont}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_up_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse-external} {FontName}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_up_tl {#1}
 }
%    \end{macrocode}
% Bold:
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_if_eq:nnT {ox}
\cs_generate_variant:Nn \prop_put:Nnn {NxV}
\@@_keys_define_code:nnn {fontspec-preparse-external} {BoldFont}
 {
  \tl_if_empty:nTF {#1}
   {
    \bool_set_true:N \l_@@_nobf_bool
   }
   {
    \bool_set_false:N \l_@@_nobf_bool
    \fontspec_complete_fontname:Nn \l_@@_curr_bfname_tl {#1}

    \seq_if_empty:NT \g_@@_bf_series_seq
     {
      \tl_gset:Nx \g_@@_curr_series_tl {\bfdefault}
      \seq_put_right:Nx \g_@@_bf_series_seq {\bfdefault}
     }
    \tl_if_eq:oxT \g_@@_curr_series_tl {\bfdefault}
     { \tl_set_eq:NN \l_fontspec_fontname_bf_tl \l_@@_curr_bfname_tl }

%<debug>\typeout{Setting~bold~font~"\l_@@_curr_bfname_tl"~with~series~"\g_@@_curr_series_tl"}

    \prop_put:NxV \l_@@_nfss_prop
     {BoldFont-\g_@@_curr_series_tl} \l_@@_curr_bfname_tl

   }
 }
\prop_new:N \l_@@_nfss_prop
%    \end{macrocode}
% Same for italic:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse-external} {ItalicFont}
 {
  \tl_if_empty:nTF {#1}
   {
    \bool_set_true:N \l_@@_noit_bool
   }
   {
    \bool_set_false:N \l_@@_noit_bool
    \fontspec_complete_fontname:Nn \l_fontspec_fontname_it_tl {#1}
   }
 }
%    \end{macrocode}
% Simpler for bold+italic \& slanted:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse-external} {BoldItalicFont}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_bfit_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse-external} {SlantedFont}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_sl_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse-external} {BoldSlantedFont}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_bfsl_tl {#1}
 }
%    \end{macrocode}
% Small caps isn't pre-parsed because it can vary with others above:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {SmallCapsFont}
 {
  \tl_if_empty:nTF {#1}
   {
    \bool_set_true:N \l_@@_nosc_bool
   }
   {
    \bool_set_false:N \l_@@_nosc_bool
    \fontspec_complete_fontname:Nn \l_fontspec_fontname_sc_tl {#1}
   }
 }
%    \end{macrocode}
%
% \begin{macro}{\fontspec_complete_fontname:Nn}
% This macro defines |#1| as the input with any |*| tokens of its input
% replaced by the font name. This lets us define supplementary fonts in full
% (``\texttt{Baskerville Semibold}'') or in abbreviation (``\texttt{* Semibold}'').
%    \begin{macrocode}
\cs_set:Nn \fontspec_complete_fontname:Nn
 {
  \tl_set:Nx #1 {#2}
  \tl_replace_all:Nnx #1 {*} {\l_@@_basename_tl}
%<luatex>  \tl_remove_all:Nn #1 {~}
 }
\cs_generate_variant:Nn \tl_replace_all:Nnn {Nnx}
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Features}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {UprightFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_up_clist {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse} {BoldFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_bf_clist {#1}

%  \prop_put:NxV \l_@@_nfss_prop
%     {BoldFont-\g_@@_curr_series_tl} \l_@@_curr_bfname_tl
 }
\@@_keys_define_code:nnn {fontspec-preparse} {ItalicFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_it_clist {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse} {BoldItalicFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_bfit_clist {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse} {SlantedFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_sl_clist {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse} {BoldSlantedFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_bfsl_clist {#1}
 }
%    \end{macrocode}
% Note that small caps features can vary by shape, so these in fact \emph{aren't} pre-parsed.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {SmallCapsFeatures}
 {
  \bool_if:NF \l_@@_firsttime_bool
   {
    \clist_set:Nn \l_@@_fontfeat_sc_clist {#1}
   }
 }
%    \end{macrocode}
%
% paragraph{Features varying by size}
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {SizeFeatures}
 {
  \clist_set:Nn \l_@@_sizefeat_clist {#1}
  \clist_put_right:Nn \l_@@_fontfeat_up_clist { SizeFeatures = {#1} }
 }
\@@_keys_define_code:nnn {fontspec-preparse-nested} {SizeFeatures}
 {
  \clist_set:Nn \l_@@_sizefeat_clist {#1}
  \tl_if_empty:NT \l_@@_this_font_tl
   { \tl_set:Nn \l_@@_this_font_tl { -- } } % needs to be non-empty as a flag
 }
\@@_keys_define_code:nnn {fontspec-preparse-nested} {Font}
 {
  \tl_set:Nn \l_@@_this_font_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec} {SizeFeatures}
 {
  % dummy
 }
\@@_keys_define_code:nnn {fontspec} {Font}
 {
  % dummy
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-sizing} {Size}
 {
  \tl_set:Nn \l_@@_size_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec-sizing} {Font}
 {
  \fontspec_complete_fontname:Nn \l_@@_sizedfont_tl {#1}
 }
%    \end{macrocode}
%
% \subsubsection{Font-independent features}
%
% These features can be applied to any font.
%
% \paragraph{NFSS encoding}
% For the very brave.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {NFSSEncoding}
 {
  \tl_gset:Nx \l_@@_nfss_enc_tl { #1 }
 }
%    \end{macrocode}
%
% \paragraph{NFSS family}
% Interactions with other packages will sometimes require setting the NFSS family explicitly.
% (By default \pkg{fontspec} auto-generates one based on the font name.)
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {NFSSFamily}
 {
  \tl_set:Nx \l_@@_nfss_fam_tl { #1 }
  \cs_undefine:c {g_@@_UID_\l_@@_fontid_tl}
  \tl_if_exist:NT \l_fontspec_family_tl
   { \cs_undefine:c {g_@@_ \l_fontspec_family_tl _prop} }
 }
%    \end{macrocode}
%
% \paragraph{NFSS series/shape}
% This option looks similar in name but has a very different function.
%    \begin{macrocode}
\prop_new:N \l_@@_nfssfont_prop
\@@_keys_define_code:nnn {fontspec} {FontFace}
 {
  \tl_set:No \l_@@_arg_tl { \use_iii:nnn #1 }
  \tl_set_eq:NN \l_@@_this_feat_tl \l_@@_arg_tl
  \tl_clear:N \l_@@_this_font_tl
  \int_compare:nT { \clist_count:N \l_@@_arg_tl = 1 }
   {
%<*debug>
    \typeout{FontFace~ parsing:~ one~ clist~ item}
%</debug>
    \tl_if_in:NnF \l_@@_arg_tl {=}
     {
%<*debug>
      \typeout{FontFace~ parsing:~ no~ equals~ =>~ font~ name~ only}
%</debug>
      \tl_set_eq:NN \l_@@_this_font_tl \l_@@_arg_tl
      \tl_clear:N \l_@@_this_feat_tl
     }
   }

  \@@_add_nfssfont:oooo
   {\use_i:nnn #1}{\use_ii:nnn #1}{\l_@@_this_font_tl}{\l_@@_this_feat_tl}
 }
%    \end{macrocode}
%
%
% \begin{macro}{\@@_add_nfssfont:nnnn}
% \darg{series}
% \darg{shape}
% \darg{fontname}
% \darg{fontspec features}
%    \begin{macrocode}
\cs_new:Nn \@@_add_nfssfont:nnnn
 {
  \tl_set:Nx \l_@@_this_font_tl {#3}

  \tl_if_empty:xTF {#4}
   { \clist_set:Nn \l_@@_sizefeat_clist {Size={-}} }
   { \keys_set_known:noN {fontspec-preparse-nested} {#4} \l_@@_tmp_tl }

  \tl_if_empty:NF \l_@@_this_font_tl
   {
    \prop_put:Nxx \l_@@_nfssfont_prop {#1/#2}
     { {#1}{#2}{\l_@@_this_font_tl}{#4}{\l_@@_sizefeat_clist} }
   }
 }
\cs_generate_variant:Nn \@@_add_nfssfont:nnnn {ooo}
\cs_generate_variant:Nn \@@_add_nfssfont:nnnn {oooo}
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Scale}
% If the input isn't one of the pre-defined string options, then
% it's gotta be numerical. \cs{fontspec_calc_scale:n} does all the work in
% the auto-scaling cases.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {Scale}
 {
  \str_case:nnF {#1}
   {
    {MatchLowercase} { \@@_calc_scale:n {5} }
    {MatchUppercase} { \@@_calc_scale:n {8} }
   }
   { \tl_set:Nx \l_@@_scale_tl {#1} }
  \tl_set:Nx \l_@@_scale_tl { s*[\l_@@_scale_tl] }
 }
%    \end{macrocode}
%
% \begin{macro}{\@@_calc_scale:n}
% This macro calculates the amount of scaling between the default
% roman font and the (default shape of) the font being selected such
% that the font dimension that is input is equal for both. The only
% font dimensions that justify this are 5 (lowercase height)
% and 8 (uppercase height in \XeTeX).
%
% This script is executed for every extra shape, which seems wasteful,
% but allows alternate italic shapes from a separate font, say, to
% be loaded and to be auto-scaled correctly. Even if this would be ugly.
%    \begin{macrocode}
\cs_new:Nn \@@_calc_scale:n
 {
  \group_begin:
    \rmfamily
    \@@_set_font_dimen:NnN \l_@@_tmpa_dim {#1} \font
    \@@_set_font_dimen:NnN \l_@@_tmpb_dim {#1} \l_fontspec_font
    \tl_gset:Nx \l_@@_scale_tl
     {
      \fp_eval:n { \dim_to_fp:n {\l_@@_tmpa_dim} /
                   \dim_to_fp:n {\l_@@_tmpb_dim} }
     }
    \@@_info:n {set-scale}
  \group_end:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_set_font_dimen:NnN}
% This function sets the dimension |#1| (for font |#3|) to `fontdimen' |#2|
% for either font dimension 5 (x-height) or 8 (cap-height). If, for some
% reason, these return an incorrect `zero' value (as \cs{fontdimen8} might
% for a \texttt{.tfm} font), then we cheat and measure the height of a glyph.
% We assume in this case that the font contains either an `X' or an `x'.
%    \begin{macrocode}
\cs_new:Nn \@@_set_font_dimen:NnN
 {
  \dim_set:Nn #1 { \fontdimen #2 #3 }
  \dim_compare:nNnT #1 = {0pt}
   {
    \settoheight #1
     {
      \str_if_eq:nnTF {#3} {\font} \rmfamily #3
      \int_case:nnn #2
       {
         {5} {x} % x-height
         {8} {X} % cap-height
       } {?} % "else" clause; never reached.
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Inter-word space}
% These options set the relevant \cmd\fontdimen s for the
% font being loaded.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {WordSpace}
 {
  \bool_if:NF \l_@@_firsttime_bool
   { \_fontspec_parse_wordspace:w #1,,,\q_stop }
 }
%    \end{macrocode}
%
% \begin{macro}{\_fontspec_parse_wordspace:w}
% This macro determines if the input to \feat{WordSpace} is
% of the form |{X}| or |{X,Y,Z}| and executes the font scaling.
% If the former input, it executes |{X,X,X}|.
%    \begin{macrocode}
\cs_set:Npn \_fontspec_parse_wordspace:w #1,#2,#3,#4 \q_stop
 {
  \tl_if_empty:nTF {#4}
   {
    \tl_set:Nn \l_@@_wordspace_adjust_tl
     {
      \fontdimen 2 \font = #1 \fontdimen 2 \font
      \fontdimen 3 \font = #1 \fontdimen 3 \font
      \fontdimen 4 \font = #1 \fontdimen 4 \font
     }
   }
   {
    \tl_set:Nn \l_@@_wordspace_adjust_tl
     {
      \fontdimen 2 \font = #1 \fontdimen 2 \font
      \fontdimen 3 \font = #2 \fontdimen 3 \font
      \fontdimen 4 \font = #3 \fontdimen 4 \font
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Punctuation space}
% Scaling factor for the nominal \cmd\fontdimen \#7.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {PunctuationSpace}
 {
  \str_case_x:nnF {#1}
   {
    {WordSpace}
    {
     \tl_set:Nn \l_@@_punctspace_adjust_tl
      { \fontdimen 7 \font = 0 \fontdimen 2 \font }
    }
    {TwiceWordSpace}
    {
     \tl_set:Nn \l_@@_punctspace_adjust_tl
      { \fontdimen 7 \font = 1 \fontdimen 2 \font }
    }
   }
   {
     \tl_set:Nn \l_@@_punctspace_adjust_tl
     { \fontdimen 7 \font = #1 \fontdimen 7 \font }
   }
 }
%    \end{macrocode}
%
% \paragraph{Secret hook into the font-adjustment code}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {FontAdjustment}
 {
  \tl_put_right:Nx \l_@@_postadjust_tl {#1}
 }
%    \end{macrocode}
%
% \paragraph{Letterspacing}
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {LetterSpace}
 {
  \@@_update_featstr:n {letterspace=#1}
 }
%    \end{macrocode}
%
% \paragraph{Hyphenation character}
% This feature takes one of three arguments: `\opt{None}',
% \meta{glyph}, or \meta{slot}. If the input isn't the first,
% and it's one character, then it's the second; otherwise, it's
% the third.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {HyphenChar}
 {
  \str_if_eq:nnTF {#1} {None}
   {
    \tl_put_right:Nn \l_@@_postadjust_tl
      { \hyphenchar \font = \c_minus_one }
   }
   {
    \tl_if_single:nTF {#1}
     { \tl_set:Nn \l_fontspec_hyphenchar_tl {`#1} }
     { \tl_set:Nn \l_fontspec_hyphenchar_tl { #1} }
    \font_glyph_if_exist:NnTF \l_fontspec_font {\l_fontspec_hyphenchar_tl}
     {
      \tl_put_right:Nn \l_@@_postadjust_tl
%<*xetexx>
        { \hyphenchar \font = \l_fontspec_hyphenchar_tl \scan_stop: }
%</xetexx>
%<*luatex>
        {
          \hyphenchar \font = \c_zero
          \int_set:Nn \luatex_prehyphenchar:D { \l_fontspec_hyphenchar_tl }
        }
%</luatex>
     }
     { \@@_error:nx {no-glyph}{#1} }
   }
 }
%    \end{macrocode}
%
% \paragraph{Color}
% Hooks into pkg{xcolor}, which names its colours \texttt{\char`\\color@<name>}.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {Color}
 {
  \cs_if_exist:cTF { \token_to_str:N \color@ #1 }
   {
    \convertcolorspec{named}{#1}{HTML}\l_@@_hexcol_tl
   }
   {
    \int_compare:nTF { \tl_count:n {#1} == 6 }
     { \tl_set:Nn \l_@@_hexcol_tl {#1} }
     {
      \int_compare:nTF { \tl_count:n {#1} == 8 }
       { \fontspec_parse_colour:viii #1 }
       {
        \bool_if:NF \l_@@_firsttime_bool
         { \@@_warning:nx {bad-colour} {#1} }
       }
     }
   }
 }
\cs_set:Npn \fontspec_parse_colour:viii #1#2#3#4#5#6#7#8
 {
  \tl_set:Nn \l_@@_hexcol_tl {#1#2#3#4#5#6}
  \tl_if_eq:NNF \l_@@_opacity_tl \g_@@_opacity_tl
   {
    \bool_if:NF \l_@@_firsttime_bool
     { \@@_warning:nx {opa-twice-col} {#7#8} }
   }
  \tl_set:Nn \l_@@_opacity_tl {#7#8}
 }
\aliasfontfeature{Color}{Colour}
%    \end{macrocode}
%    \begin{macrocode}
\int_new:N \l_@@_tmp_int
\@@_keys_define_code:nnn {fontspec} {Opacity}
 {
  \int_set:Nn \l_@@_tmp_int {255}
  \@@_int_mult_truncate:Nn \l_@@_tmp_int { #1 }
  \tl_if_eq:NNF \l_@@_opacity_tl \g_@@_opacity_tl
   {
    \bool_if:NF \l_@@_firsttime_bool
     { \@@_warning:nx {opa-twice} {#1} }
   }
  \tl_set:Nx \l_@@_opacity_tl
   {
     \int_compare:nT { \l_@@_tmp_int <= "F } {0} % zero pad
     \int_to_hex:n { \l_@@_tmp_int }
   }
 }
%    \end{macrocode}
%
%
% \paragraph{Mapping}
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {Mapping}
%<*xetexx>
 {
  \@@_update_featstr:n { mapping = #1 }
 }
%</xetexx>
%<*luatex>
 {
  \str_if_eq:nnTF {#1} {tex-text}
   {
    \@@_warning:n {no-mapping-ligtex}
    \msg_redirect_name:nnn {fontspec} {no-mapping-ligtex} {none}
    \keys_set:nn {fontspec} { Ligatures=TeX }
   }
   { \@@_warning:n {no-mapping} }
 }
%</luatex>
%    \end{macrocode}
%
% \paragraph{FeatureFile}
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {FeatureFile}
 {
  \@@_update_featstr:n { featurefile = #1 }
 }
%    \end{macrocode}
%
%
% \subsubsection{Continuous font axes}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {Weight}
 {
  \@@_update_featstr:n{weight=#1}
 }
\@@_keys_define_code:nnn {fontspec} {Width}
 {
  \@@_update_featstr:n{width=#1}
 }
\@@_keys_define_code:nnn {fontspec} {OpticalSize}
%<*xetexx>
 {
  \bool_if:NTF \l_@@_ot_bool
   {
    \tl_set:Nn \l_@@_optical_size_tl {/ S = #1}
   }
   {
    \bool_if:NT \l_@@_mm_bool
     {
      \@@_update_featstr:n { optical size = #1 }
     }
   }
  \bool_if:nT { !\l_@@_ot_bool && !\l_@@_mm_bool }
   {
    \bool_if:NT \l_@@_firsttime_bool
     { \@@_warning:n {no-opticals} }
   }
 }
%</xetexx>
%<*luatex>
 {
  \tl_set:Nn \l_@@_optical_size_tl {/ S = #1}
 }
%</luatex>
%    \end{macrocode}
%
% \subsubsection{Font transformations}
% These are to be specified to apply directly to a font shape:
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  FakeSlant .code:n =
   {
    \@@_update_featstr:n{slant=#1}
   },
  FakeSlant .default:n = {0.2}
}
\keys_define:nn {fontspec}
 {
  FakeStretch .code:n =
   {
    \@@_update_featstr:n{extend=#1}
   },
  FakeStretch .default:n = {1.2}
}
%<*xetexx>
\keys_define:nn {fontspec}
 {
  FakeBold .code:n =
   {
    \@@_update_featstr:n {embolden=#1}
   },
  FakeBold .default:n = {1.5}
 }
%</xetexx>
%<*luatex>
\keys_define:nn {fontspec}
 {
  FakeBold .code:n = { \@@_warning:n {fakebold-only-xetex} }
 }
%</luatex>
%    \end{macrocode}
% These are to be given to a shape that has no real bold/italic
% to signal that \pkg{fontspec} should automatically create `fake' shapes.
%
% The behaviour is currently that only if both \opt{AutoFakeSlant} \emph{and}
% \opt{AutoFakeBold} are specified, the bold italic is also faked.
%
% These features presently \emph{override} real shapes found in the font;
% in the future I'd like these features to be ignored in this case, instead.
% (This is just a bit harder to program in the current design of
% \pkg{fontspec}.)
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  AutoFakeSlant .code:n =
   {
    \bool_if:NT \l_@@_firsttime_bool
     {
      \tl_set:Nn \l_fontspec_fake_slant_tl {#1}
      \clist_put_right:Nn \l_@@_fontfeat_it_clist {FakeSlant=#1}
      \tl_set_eq:NN \l_fontspec_fontname_it_tl \l_fontspec_fontname_tl
      \bool_set_false:N \l_@@_noit_bool

      \tl_if_empty:NF \l_fontspec_fake_embolden_tl
       {
        \clist_put_right:Nx \l_@@_fontfeat_bfit_clist
         {FakeBold=\l_fontspec_fake_embolden_tl}
        \clist_put_right:Nx \l_@@_fontfeat_bfit_clist {FakeSlant=#1}
        \tl_set_eq:NN \l_fontspec_fontname_bfit_tl \l_fontspec_fontname_tl
       }
     }
   },
  AutoFakeSlant .default:n = {0.2}
}
%    \end{macrocode}
% Same but reversed:
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  AutoFakeBold .code:n =
   {
    \bool_if:NT \l_@@_firsttime_bool
     {
      \tl_set:Nn \l_fontspec_fake_embolden_tl {#1}
      \clist_put_right:Nn \l_@@_fontfeat_bf_clist {FakeBold=#1}
      \tl_set_eq:NN \l_fontspec_fontname_bf_tl \l_fontspec_fontname_tl
      \bool_set_false:N \l_@@_nobf_bool

      \tl_if_empty:NF \l_fontspec_fake_slant_tl
       {
        \clist_put_right:Nx \l_@@_fontfeat_bfit_clist
         {FakeSlant=\l_fontspec_fake_slant_tl}
        \clist_put_right:Nx \l_@@_fontfeat_bfit_clist {FakeBold=#1}
        \tl_set_eq:NN \l_fontspec_fontname_bfit_tl \l_fontspec_fontname_tl
       }
     }
   },
  AutoFakeBold .default:n = {1.5}
}
%    \end{macrocode}
%
%
% \subsubsection{Ligatures}
% The call to the nested keyval family must be wrapped in braces to
% hide the parent list (this later requires the use of global
% definitions (|\xdef|) in [...]). Both \AAT\ and OpenType
% names are offered to chose |Rare|/|Discretionary| ligatures.
%    \begin{macrocode}
\@@_define_font_feature:n{Ligatures}
\@@_define_feature_option:nnnnn{Ligatures}{Required}       {1}{0}{+rlig}
\@@_define_feature_option:nnnnn{Ligatures}{NoRequired}     {1}{1}{-rlig}
\@@_define_feature_option:nnnnn{Ligatures}{Common}         {1}{2}{+liga}
\@@_define_feature_option:nnnnn{Ligatures}{NoCommon}       {1}{3}{-liga}
\@@_define_feature_option:nnnnn{Ligatures}{Rare}           {1}{4}{+dlig}
\@@_define_feature_option:nnnnn{Ligatures}{NoRare}         {1}{5}{-dlig}
\@@_define_feature_option:nnnnn{Ligatures}{Discretionary}  {1}{4}{+dlig}
\@@_define_feature_option:nnnnn{Ligatures}{NoDiscretionary}{1}{5}{-dlig}
\@@_define_feature_option:nnnnn{Ligatures}{Contextual}     {}{}  {+clig}
\@@_define_feature_option:nnnnn{Ligatures}{NoContextual}   {}{}  {-clig}
\@@_define_feature_option:nnnnn{Ligatures}{Historic}       {}{}  {+hlig}
\@@_define_feature_option:nnnnn{Ligatures}{NoHistoric}     {}{}  {-hlig}
\@@_define_feature_option:nnnnn{Ligatures}{Logos}          {1}{6} {}
\@@_define_feature_option:nnnnn{Ligatures}{NoLogos}        {1}{7} {}
\@@_define_feature_option:nnnnn{Ligatures}{Rebus}          {1}{8} {}
\@@_define_feature_option:nnnnn{Ligatures}{NoRebus}        {1}{9} {}
\@@_define_feature_option:nnnnn{Ligatures}{Diphthong}      {1}{10}{}
\@@_define_feature_option:nnnnn{Ligatures}{NoDiphthong}    {1}{11}{}
\@@_define_feature_option:nnnnn{Ligatures}{Squared}        {1}{12}{}
\@@_define_feature_option:nnnnn{Ligatures}{NoSquared}      {1}{13}{}
\@@_define_feature_option:nnnnn{Ligatures}{AbbrevSquared}  {1}{14}{}
\@@_define_feature_option:nnnnn{Ligatures}{NoAbbrevSquared}{1}{15}{}
\@@_define_feature_option:nnnnn{Ligatures}{Icelandic}      {1}{32}{}
\@@_define_feature_option:nnnnn{Ligatures}{NoIcelandic}    {1}{33}{}
%    \end{macrocode}
% Emulate CM extra ligatures.
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  Ligatures / TeX .code:n =
   {
%<*xetexx>
    \@@_update_featstr:n { mapping = tex-text }
%</xetexx>
%<*luatex>
    \@@_update_featstr:n { +tlig; +trep }
%</luatex>
   }
 }
%    \end{macrocode}
%
% \subsubsection{Letters}
%    \begin{macrocode}
\@@_define_font_feature:n{Letters}
\@@_define_feature_option:nnnnn{Letters}{Normal}             {3}{0}{}
\@@_define_feature_option:nnnnn{Letters}{Uppercase}          {3}{1}{+case}
\@@_define_feature_option:nnnnn{Letters}{Lowercase}          {3}{2}{}
\@@_define_feature_option:nnnnn{Letters}{SmallCaps}          {3}{3}{+smcp}
\@@_define_feature_option:nnnnn{Letters}{PetiteCaps}         {} {} {+pcap}
\@@_define_feature_option:nnnnn{Letters}{UppercaseSmallCaps} {} {} {+c2sc}
\@@_define_feature_option:nnnnn{Letters}{UppercasePetiteCaps}{} {} {+c2pc}
\@@_define_feature_option:nnnnn{Letters}{InitialCaps}        {3}{4}{}
\@@_define_feature_option:nnnnn{Letters}{Unicase}            {} {} {+unic}
\@@_define_feature_option:nnnnn{Letters}{Random}             {} {} {+rand}
%    \end{macrocode}
%
% \subsubsection{Numbers}
%
% These were originally separated into \feat{NumberCase} and
% \feat{NumberSpacing} following \AAT, but it makes more sense to
% combine them.
%
% Both naming conventions are offered to select the number case.
%
%    \begin{macrocode}
\@@_define_font_feature:n{Numbers}
\@@_define_feature_option:nnnnn{Numbers}{Monospaced}   {6} {0}{+tnum}
\@@_define_feature_option:nnnnn{Numbers}{Proportional} {6} {1}{+pnum}
\@@_define_feature_option:nnnnn{Numbers}{Lowercase}    {21}{0}{+onum}
\@@_define_feature_option:nnnnn{Numbers}{OldStyle}     {21}{0}{+onum}
\@@_define_feature_option:nnnnn{Numbers}{Uppercase}    {21}{1}{+lnum}
\@@_define_feature_option:nnnnn{Numbers}{Lining}       {21}{1}{+lnum}
\@@_define_feature_option:nnnnn{Numbers}{SlashedZero}  {14}{5}{+zero}
\@@_define_feature_option:nnnnn{Numbers}{NoSlashedZero}{14}{4}{-zero}
%    \end{macrocode}
%
% |luaotload| provides a custom |anum| feature for replacing Latin
% (AKA Arabic) numbers with Arabic (AKA Indic-Arabic). The same feature
% maps to Farsi (Persian) numbers if font language is Farsi.
%
%    \begin{macrocode}
\luatex_if_engine:T
 {
  \@@_define_feature_option:nnnnn{Numbers}{Arabic}{}{}{+anum}
 }
%    \end{macrocode}
%
% \subsubsection{Contextuals}
%    \begin{macrocode}
\@@_define_font_feature:n  {Contextuals}
\@@_define_feature_option:nnnnn{Contextuals}{Swash}        {} {} {+cswh}
\@@_define_feature_option:nnnnn{Contextuals}{NoSwash}      {} {} {-cswh}
\@@_define_feature_option:nnnnn{Contextuals}{Alternate}    {} {} {+calt}
\@@_define_feature_option:nnnnn{Contextuals}{NoAlternate}  {} {} {-calt}
\@@_define_feature_option:nnnnn{Contextuals}{WordInitial}  {8}{0}{+init}
\@@_define_feature_option:nnnnn{Contextuals}{NoWordInitial}{8}{1}{-init}
\@@_define_feature_option:nnnnn{Contextuals}{WordFinal}    {8}{2}{+fina}
\@@_define_feature_option:nnnnn{Contextuals}{NoWordFinal}  {8}{3}{-fina}
\@@_define_feature_option:nnnnn{Contextuals}{LineInitial}  {8}{4}{}
\@@_define_feature_option:nnnnn{Contextuals}{NoLineInitial}{8}{5}{}
\@@_define_feature_option:nnnnn{Contextuals}{LineFinal}    {8}{6}{+falt}
\@@_define_feature_option:nnnnn{Contextuals}{NoLineFinal}  {8}{7}{-falt}
\@@_define_feature_option:nnnnn{Contextuals}{Inner}        {8}{8}{+medi}
\@@_define_feature_option:nnnnn{Contextuals}{NoInner}      {8}{9}{-medi}
%    \end{macrocode}
%
% \subsubsection{Diacritics}
%    \begin{macrocode}
\@@_define_font_feature:n{Diacritics}
\@@_define_feature_option:nnnnn{Diacritics}{Show}        {9}{0}{}
\@@_define_feature_option:nnnnn{Diacritics}{Hide}        {9}{1}{}
\@@_define_feature_option:nnnnn{Diacritics}{Decompose}   {9}{2}{}
\@@_define_feature_option:nnnnn{Diacritics}{MarkToBase}  {}{}{+mark}
\@@_define_feature_option:nnnnn{Diacritics}{NoMarkToBase}{}{}{-mark}
\@@_define_feature_option:nnnnn{Diacritics}{MarkToMark}  {}{}{+mkmk}
\@@_define_feature_option:nnnnn{Diacritics}{NoMarkToMark}{}{}{-mkmk}
\@@_define_feature_option:nnnnn{Diacritics}{AboveBase}   {}{}{+abvm}
\@@_define_feature_option:nnnnn{Diacritics}{NoAboveBase} {}{}{-abvm}
\@@_define_feature_option:nnnnn{Diacritics}{BelowBase}   {}{}{+blwm}
\@@_define_feature_option:nnnnn{Diacritics}{NoBelowBase} {}{}{-blwm}
%    \end{macrocode}
%
% \subsubsection{Kerning}
%    \begin{macrocode}
\@@_define_font_feature:n{Kerning}
\@@_define_feature_option:nnnnn{Kerning}{Uppercase}{}{}{+cpsp}
\@@_define_feature_option:nnnnn{Kerning}{On}       {}{}{+kern}
\@@_define_feature_option:nnnnn{Kerning}{Off}      {}{}{-kern}
%\@@_define_feature_option:nnnnn{Kerning}{Vertical}{}{}{+vkrn}
%\@@_define_feature_option:nnnnn{Kerning}
%    {VerticalAlternateProportional}{}{}{+vpal}
%\@@_define_feature_option:nnnnn{Kerning}{VerticalAlternateHalfWidth}{}{}{+vhal}
%    \end{macrocode}
%
% \subsubsection{Vertical position}
%    \begin{macrocode}
\@@_define_font_feature:n{VerticalPosition}
\@@_define_feature_option:nnnnn{VerticalPosition}{Normal}     {10}{0}{}
\@@_define_feature_option:nnnnn{VerticalPosition}{Superior}   {10}{1}{+sups}
\@@_define_feature_option:nnnnn{VerticalPosition}{Inferior}   {10}{2}{+subs}
\@@_define_feature_option:nnnnn{VerticalPosition}{Ordinal}    {10}{3}{+ordn}
\@@_define_feature_option:nnnnn{VerticalPosition}{Numerator}  {}  {} {+numr}
\@@_define_feature_option:nnnnn{VerticalPosition}{Denominator}{}  {} {+dnom}
\@@_define_feature_option:nnnnn{VerticalPosition}{ScientificInferior}{}{}{+sinf}
%    \end{macrocode}
%
% \subsubsection{Fractions}
%    \begin{macrocode}
\@@_define_font_feature:n{Fractions}
\@@_define_feature_option:nnnnn{Fractions}{On}       {11}{1}{+frac}
\@@_define_feature_option:nnnnn{Fractions}{Off}      {11}{0}{-frac}
\@@_define_feature_option:nnnnn{Fractions}{Diagonal} {11}{2}{}
\@@_define_feature_option:nnnnn{Fractions}{Alternate}{}  {} {+afrc}
%    \end{macrocode}
%
% \subsubsection{Alternates and variants}
% Selected numerically because they don't have standard names. Very
% easy to process, very annoying for the user!
%
%    \begin{macrocode}
\@@_define_font_feature:n { Alternate }
\keys_define:nn {fontspec}
 {
  Alternate .default:n = {0} ,
  Alternate / unknown .code:n =
   {
    \clist_map_inline:nn {#1}
      { \fontspec_make_feature:nnx {17}{##1} { \fontspec_salt:n {##1} } }
   }
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Nn \fontspec_salt:n { +salt = #1 }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_define_font_feature:n {Variant}
\keys_define:nn {fontspec}
 {
  Variant .default:n = {0} ,
  Variant / unknown .code:n =
   {
    \clist_map_inline:nn {#1}
      { \fontspec_make_feature:nnx {18}{##1} { +ss \two@digits {##1} } }
   }
 }
\aliasfontfeature{Variant}{StylisticSet}
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_define_font_feature:n { CharacterVariant }
\use:x
 {
  \cs_new:Npn \exp_not:N \fontspec_parse_cv:w
      ##1 \c_colon_str ##2 \c_colon_str ##3 \exp_not:N \q_nil
   {
     \fontspec_make_numbered_feature:xn
       { +cv \exp_not:N \two@digits {##1} } {##2}
   }
  \keys_define:nn {fontspec}
   {
    CharacterVariant / unknown .code:n =
     {
      \clist_map_inline:nn {##1}
       {
        \exp_not:N \fontspec_parse_cv:w
          ####1 \c_colon_str 0 \c_colon_str \exp_not:N \q_nil
       }
     }
   }
 }
%    \end{macrocode}
% Possibilities: \verb|a:0:\q_nil| or \verb|a:b:0:\q_nil|.
%
%
%
% \subsubsection{Style}
%    \begin{macrocode}
\@@_define_font_feature:n{Style}
\@@_define_feature_option:nnnnn{Style}{Alternate}     {}  {} {+salt}
\@@_define_feature_option:nnnnn{Style}{Italic}        {32}{2}{+ital}
\@@_define_feature_option:nnnnn{Style}{Ruby}          {28}{2}{+ruby}
\@@_define_feature_option:nnnnn{Style}{Swash}         {}  {} {+swsh}
\@@_define_feature_option:nnnnn{Style}{Historic}      {}  {} {+hist}
\@@_define_feature_option:nnnnn{Style}{Display}       {19}{1}{}
\@@_define_feature_option:nnnnn{Style}{Engraved}      {19}{2}{}
\@@_define_feature_option:nnnnn{Style}{TitlingCaps}   {19}{4}{+titl}
\@@_define_feature_option:nnnnn{Style}{TallCaps}      {19}{5}{}
\@@_define_feature_option:nnnnn{Style}{HorizontalKana}{}  {} {+hkna}
\@@_define_feature_option:nnnnn{Style}{VerticalKana}  {}  {} {+vkna}
\fontspec_define_numbered_feat:nnnn {Style} {MathScript}       {+ssty} {0}
\fontspec_define_numbered_feat:nnnn {Style} {MathScriptScript} {+ssty} {1}
%    \end{macrocode}
%
% \subsubsection{CJK shape}
%    \begin{macrocode}
\@@_define_font_feature:n{CJKShape}
\@@_define_feature_option:nnnnn{CJKShape}{Traditional}{20}{0} {+trad}
\@@_define_feature_option:nnnnn{CJKShape}{Simplified} {20}{1} {+smpl}
\@@_define_feature_option:nnnnn{CJKShape}{JIS1978}    {20}{2} {+jp78}
\@@_define_feature_option:nnnnn{CJKShape}{JIS1983}    {20}{3} {+jp83}
\@@_define_feature_option:nnnnn{CJKShape}{JIS1990}    {20}{4} {+jp90}
\@@_define_feature_option:nnnnn{CJKShape}{Expert}     {20}{10}{+expt}
\@@_define_feature_option:nnnnn{CJKShape}{NLC}        {20}{13}{+nlck}
%    \end{macrocode}
%
% \subsubsection{Character width}
%    \begin{macrocode}
\@@_define_font_feature:n{CharacterWidth}
\@@_define_feature_option:nnnnn{CharacterWidth}{Proportional}{22}{0}{+pwid}
\@@_define_feature_option:nnnnn{CharacterWidth}{Full}{22}{1}{+fwid}
\@@_define_feature_option:nnnnn{CharacterWidth}{Half}{22}{2}{+hwid}
\@@_define_feature_option:nnnnn{CharacterWidth}{Third}{22}{3}{+twid}
\@@_define_feature_option:nnnnn{CharacterWidth}{Quarter}{22}{4}{+qwid}
\@@_define_feature_option:nnnnn{CharacterWidth}{AlternateProportional}{22}{5}{+palt}
\@@_define_feature_option:nnnnn{CharacterWidth}{AlternateHalf}{22}{6}{+halt}
\@@_define_feature_option:nnnnn{CharacterWidth}{Default}{22}{7}{}
%    \end{macrocode}
%
% \subsubsection{Annotation}
%    \begin{macrocode}
\@@_define_feature_option:nnnnn{Annotation}{Off}{24}{0}{}
\@@_define_feature_option:nnnnn{Annotation}{Box}{24}{1}{}
\@@_define_feature_option:nnnnn{Annotation}{RoundedBox}{24}{2}{}
\@@_define_feature_option:nnnnn{Annotation}{Circle}{24}{3}{}
\@@_define_feature_option:nnnnn{Annotation}{BlackCircle}{24}{4}{}
\@@_define_feature_option:nnnnn{Annotation}{Parenthesis}{24}{5}{}
\@@_define_feature_option:nnnnn{Annotation}{Period}{24}{6}{}
\@@_define_feature_option:nnnnn{Annotation}{RomanNumerals}{24}{7}{}
\@@_define_feature_option:nnnnn{Annotation}{Diamond}{24}{8}{}
\@@_define_feature_option:nnnnn{Annotation}{BlackSquare}{24}{9}{}
\@@_define_feature_option:nnnnn{Annotation}{BlackRoundSquare}{24}{10}{}
\@@_define_feature_option:nnnnn{Annotation}{DoubleCircle}{24}{11}{}
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_define_font_feature:n { Annotation }
\keys_define:nn {fontspec}
 {
  Annotation .default:n = {0} ,
  Annotation / unknown .code:n =
   {
    \fontspec_make_feature:nnx {}{}{ +nalt=#1 }
   }
 }
%    \end{macrocode}
%
%
% \subsubsection{Vertical}
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  Vertical .choice: ,
  Vertical / RotatedGlyphs .code:n =
   {
    \bool_if:NTF \l_@@_ot_bool
     {
      \fontspec_make_feature:nnn{}{}{+vrt2}
      \@@_update_featstr:n {vertical}
     }
     {
      \@@_update_featstr:n {vertical}
     }
   }
 }
%    \end{macrocode}
%
% \subsubsection{Script}
%    \begin{macrocode}
\newfontscript{Arabic}{arab}            \newfontscript{Armenian}{armn}
\newfontscript{Balinese}{bali}          \newfontscript{Bengali}{beng}
\newfontscript{Bopomofo}{bopo}          \newfontscript{Braille}{brai}
\newfontscript{Buginese}{bugi}          \newfontscript{Buhid}{buhd}
\newfontscript{Byzantine~Music}{byzm}
\newfontscript{Canadian~Syllabics}{cans}
\newfontscript{Cherokee}{cher}
\newfontscript{CJK~Ideographic}{hani}   \newfontscript{Coptic}{copt}
\newfontscript{Cypriot~Syllabary}{cprt} \newfontscript{Cyrillic}{cyrl}
\newfontscript{Default}{DFLT}           \newfontscript{Deseret}{dsrt}
\newfontscript{Devanagari}{deva}        \newfontscript{Ethiopic}{ethi}
\newfontscript{Georgian}{geor}          \newfontscript{Glagolitic}{glag}
\newfontscript{Gothic}{goth}            \newfontscript{Greek}{grek}
\newfontscript{Gujarati}{gujr}          \newfontscript{Gurmukhi}{guru}
\newfontscript{Hangul~Jamo}{jamo}       \newfontscript{Hangul}{hang}
\newfontscript{Hanunoo}{hano}           \newfontscript{Hebrew}{hebr}
\newfontscript{Hiragana~and~Katakana}{kana}
\newfontscript{Javanese}{java}          \newfontscript{Kannada}{knda}
\newfontscript{Kharosthi}{khar}         \newfontscript{Khmer}{khmr}
\newfontscript{Lao}{lao~}               \newfontscript{Latin}{latn}
\newfontscript{Limbu}{limb}             \newfontscript{Linear~B}{linb}
\newfontscript{Malayalam}{mlym}         \newfontscript{Math}{math}
\newfontscript{Mongolian}{mong}
\newfontscript{Musical~Symbols}{musc}   \newfontscript{Myanmar}{mymr}
\newfontscript{N'ko}{nko~}              \newfontscript{Ogham}{ogam}
\newfontscript{Old~Italic}{ital}
\newfontscript{Old~Persian~Cuneiform}{xpeo}
\newfontscript{Oriya}{orya}             \newfontscript{Osmanya}{osma}
\newfontscript{Phags-pa}{phag}          \newfontscript{Phoenician}{phnx}
\newfontscript{Runic}{runr}             \newfontscript{Shavian}{shaw}
\newfontscript{Sinhala}{sinh}
\newfontscript{Sumero-Akkadian~Cuneiform}{xsux}
\newfontscript{Syloti~Nagri}{sylo}      \newfontscript{Syriac}{syrc}
\newfontscript{Tagalog}{tglg}           \newfontscript{Tagbanwa}{tagb}
\newfontscript{Tai~Le}{tale}            \newfontscript{Tai~Lu}{talu}
\newfontscript{Tamil}{taml}             \newfontscript{Telugu}{telu}
\newfontscript{Thaana}{thaa}            \newfontscript{Thai}{thai}
\newfontscript{Tibetan}{tibt}           \newfontscript{Tifinagh}{tfng}
\newfontscript{Ugaritic~Cuneiform}{ugar}\newfontscript{Yi}{yi~~}
%    \end{macrocode}
% For convenience:
%    \begin{macrocode}
\newfontscript{Kana}{kana}
\newfontscript{Maths}{math}
\newfontscript{CJK}{hani}
%    \end{macrocode}
%
% \subsubsection{Language}
%    \begin{macrocode}
\newfontlanguage{Abaza}{ABA}\newfontlanguage{Abkhazian}{ABK}
\newfontlanguage{Adyghe}{ADY}\newfontlanguage{Afrikaans}{AFK}
\newfontlanguage{Afar}{AFR}\newfontlanguage{Agaw}{AGW}
\newfontlanguage{Altai}{ALT}\newfontlanguage{Amharic}{AMH}
\newfontlanguage{Arabic}{ARA}\newfontlanguage{Aari}{ARI}
\newfontlanguage{Arakanese}{ARK}\newfontlanguage{Assamese}{ASM}
\newfontlanguage{Athapaskan}{ATH}\newfontlanguage{Avar}{AVR}
\newfontlanguage{Awadhi}{AWA}\newfontlanguage{Aymara}{AYM}
\newfontlanguage{Azeri}{AZE}\newfontlanguage{Badaga}{BAD}
\newfontlanguage{Baghelkhandi}{BAG}\newfontlanguage{Balkar}{BAL}
\newfontlanguage{Baule}{BAU}\newfontlanguage{Berber}{BBR}
\newfontlanguage{Bench}{BCH}\newfontlanguage{Bible~Cree}{BCR}
\newfontlanguage{Belarussian}{BEL}\newfontlanguage{Bemba}{BEM}
\newfontlanguage{Bengali}{BEN}\newfontlanguage{Bulgarian}{BGR}
\newfontlanguage{Bhili}{BHI}\newfontlanguage{Bhojpuri}{BHO}
\newfontlanguage{Bikol}{BIK}\newfontlanguage{Bilen}{BIL}
\newfontlanguage{Blackfoot}{BKF}\newfontlanguage{Balochi}{BLI}
\newfontlanguage{Balante}{BLN}\newfontlanguage{Balti}{BLT}
\newfontlanguage{Bambara}{BMB}\newfontlanguage{Bamileke}{BML}
\newfontlanguage{Breton}{BRE}\newfontlanguage{Brahui}{BRH}
\newfontlanguage{Braj~Bhasha}{BRI}\newfontlanguage{Burmese}{BRM}
\newfontlanguage{Bashkir}{BSH}\newfontlanguage{Beti}{BTI}
\newfontlanguage{Catalan}{CAT}\newfontlanguage{Cebuano}{CEB}
\newfontlanguage{Chechen}{CHE}\newfontlanguage{Chaha~Gurage}{CHG}
\newfontlanguage{Chattisgarhi}{CHH}\newfontlanguage{Chichewa}{CHI}
\newfontlanguage{Chukchi}{CHK}\newfontlanguage{Chipewyan}{CHP}
\newfontlanguage{Cherokee}{CHR}\newfontlanguage{Chuvash}{CHU}
\newfontlanguage{Comorian}{CMR}\newfontlanguage{Coptic}{COP}
\newfontlanguage{Cree}{CRE}\newfontlanguage{Carrier}{CRR}
\newfontlanguage{Crimean~Tatar}{CRT}\newfontlanguage{Church~Slavonic}{CSL}
\newfontlanguage{Czech}{CSY}\newfontlanguage{Danish}{DAN}
\newfontlanguage{Dargwa}{DAR}\newfontlanguage{Woods~Cree}{DCR}
\newfontlanguage{German}{DEU}
\newfontlanguage{Dogri}{DGR}\newfontlanguage{Divehi}{DIV}
\newfontlanguage{Djerma}{DJR}\newfontlanguage{Dangme}{DNG}
\newfontlanguage{Dinka}{DNK}\newfontlanguage{Dungan}{DUN}
\newfontlanguage{Dzongkha}{DZN}\newfontlanguage{Ebira}{EBI}
\newfontlanguage{Eastern~Cree}{ECR}\newfontlanguage{Edo}{EDO}
\newfontlanguage{Efik}{EFI}\newfontlanguage{Greek}{ELL}
\newfontlanguage{English}{ENG}\newfontlanguage{Erzya}{ERZ}
\newfontlanguage{Spanish}{ESP}\newfontlanguage{Estonian}{ETI}
\newfontlanguage{Basque}{EUQ}\newfontlanguage{Evenki}{EVK}
\newfontlanguage{Even}{EVN}\newfontlanguage{Ewe}{EWE}
\newfontlanguage{French~Antillean}{FAN}
\newfontlanguage{Farsi}{FAR}
\newfontlanguage{Parsi}{FAR}
\newfontlanguage{Persian}{FAR}
\newfontlanguage{Finnish}{FIN}\newfontlanguage{Fijian}{FJI}
\newfontlanguage{Flemish}{FLE}\newfontlanguage{Forest~Nenets}{FNE}
\newfontlanguage{Fon}{FON}\newfontlanguage{Faroese}{FOS}
\newfontlanguage{French}{FRA}\newfontlanguage{Frisian}{FRI}
\newfontlanguage{Friulian}{FRL}\newfontlanguage{Futa}{FTA}
\newfontlanguage{Fulani}{FUL}\newfontlanguage{Ga}{GAD}
\newfontlanguage{Gaelic}{GAE}\newfontlanguage{Gagauz}{GAG}
\newfontlanguage{Galician}{GAL}\newfontlanguage{Garshuni}{GAR}
\newfontlanguage{Garhwali}{GAW}\newfontlanguage{Ge'ez}{GEZ}
\newfontlanguage{Gilyak}{GIL}\newfontlanguage{Gumuz}{GMZ}
\newfontlanguage{Gondi}{GON}\newfontlanguage{Greenlandic}{GRN}
\newfontlanguage{Garo}{GRO}\newfontlanguage{Guarani}{GUA}
\newfontlanguage{Gujarati}{GUJ}\newfontlanguage{Haitian}{HAI}
\newfontlanguage{Halam}{HAL}\newfontlanguage{Harauti}{HAR}
\newfontlanguage{Hausa}{HAU}\newfontlanguage{Hawaiin}{HAW}
\newfontlanguage{Hammer-Banna}{HBN}\newfontlanguage{Hiligaynon}{HIL}
\newfontlanguage{Hindi}{HIN}\newfontlanguage{High~Mari}{HMA}
\newfontlanguage{Hindko}{HND}\newfontlanguage{Ho}{HO}
\newfontlanguage{Harari}{HRI}\newfontlanguage{Croatian}{HRV}
\newfontlanguage{Hungarian}{HUN}\newfontlanguage{Armenian}{HYE}
\newfontlanguage{Igbo}{IBO}\newfontlanguage{Ijo}{IJO}
\newfontlanguage{Ilokano}{ILO}\newfontlanguage{Indonesian}{IND}
\newfontlanguage{Ingush}{ING}\newfontlanguage{Inuktitut}{INU}
\newfontlanguage{Irish}{IRI}\newfontlanguage{Irish~Traditional}{IRT}
\newfontlanguage{Icelandic}{ISL}\newfontlanguage{Inari~Sami}{ISM}
\newfontlanguage{Italian}{ITA}\newfontlanguage{Hebrew}{IWR}
\newfontlanguage{Javanese}{JAV}\newfontlanguage{Yiddish}{JII}
\newfontlanguage{Japanese}{JAN}\newfontlanguage{Judezmo}{JUD}
\newfontlanguage{Jula}{JUL}\newfontlanguage{Kabardian}{KAB}
\newfontlanguage{Kachchi}{KAC}\newfontlanguage{Kalenjin}{KAL}
\newfontlanguage{Kannada}{KAN}\newfontlanguage{Karachay}{KAR}
\newfontlanguage{Georgian}{KAT}\newfontlanguage{Kazakh}{KAZ}
\newfontlanguage{Kebena}{KEB}\newfontlanguage{Khutsuri~Georgian}{KGE}
\newfontlanguage{Khakass}{KHA}\newfontlanguage{Khanty-Kazim}{KHK}
\newfontlanguage{Khmer}{KHM}\newfontlanguage{Khanty-Shurishkar}{KHS}
\newfontlanguage{Khanty-Vakhi}{KHV}\newfontlanguage{Khowar}{KHW}
\newfontlanguage{Kikuyu}{KIK}\newfontlanguage{Kirghiz}{KIR}
\newfontlanguage{Kisii}{KIS}\newfontlanguage{Kokni}{KKN}
\newfontlanguage{Kalmyk}{KLM}\newfontlanguage{Kamba}{KMB}
\newfontlanguage{Kumaoni}{KMN}\newfontlanguage{Komo}{KMO}
\newfontlanguage{Komso}{KMS}\newfontlanguage{Kanuri}{KNR}
\newfontlanguage{Kodagu}{KOD}\newfontlanguage{Korean~Old~Hangul}{KOH}
\newfontlanguage{Konkani}{KOK}\newfontlanguage{Kikongo}{KON}
\newfontlanguage{Komi-Permyak}{KOP}\newfontlanguage{Korean}{KOR}
\newfontlanguage{Komi-Zyrian}{KOZ}\newfontlanguage{Kpelle}{KPL}
\newfontlanguage{Krio}{KRI}\newfontlanguage{Karakalpak}{KRK}
\newfontlanguage{Karelian}{KRL}\newfontlanguage{Karaim}{KRM}
\newfontlanguage{Karen}{KRN}\newfontlanguage{Koorete}{KRT}
\newfontlanguage{Kashmiri}{KSH}\newfontlanguage{Khasi}{KSI}
\newfontlanguage{Kildin~Sami}{KSM}\newfontlanguage{Kui}{KUI}
\newfontlanguage{Kulvi}{KUL}\newfontlanguage{Kumyk}{KUM}
\newfontlanguage{Kurdish}{KUR}\newfontlanguage{Kurukh}{KUU}
\newfontlanguage{Kuy}{KUY}\newfontlanguage{Koryak}{KYK}
\newfontlanguage{Ladin}{LAD}\newfontlanguage{Lahuli}{LAH}
\newfontlanguage{Lak}{LAK}\newfontlanguage{Lambani}{LAM}
\newfontlanguage{Lao}{LAO}\newfontlanguage{Latin}{LAT}
\newfontlanguage{Laz}{LAZ}\newfontlanguage{L-Cree}{LCR}
\newfontlanguage{Ladakhi}{LDK}\newfontlanguage{Lezgi}{LEZ}
\newfontlanguage{Lingala}{LIN}\newfontlanguage{Low~Mari}{LMA}
\newfontlanguage{Limbu}{LMB}\newfontlanguage{Lomwe}{LMW}
\newfontlanguage{Lower~Sorbian}{LSB}\newfontlanguage{Lule~Sami}{LSM}
\newfontlanguage{Lithuanian}{LTH}\newfontlanguage{Luba}{LUB}
\newfontlanguage{Luganda}{LUG}\newfontlanguage{Luhya}{LUH}
\newfontlanguage{Luo}{LUO}\newfontlanguage{Latvian}{LVI}
\newfontlanguage{Majang}{MAJ}\newfontlanguage{Makua}{MAK}
\newfontlanguage{Malayalam~Traditional}{MAL}\newfontlanguage{Mansi}{MAN}
\newfontlanguage{Marathi}{MAR}\newfontlanguage{Marwari}{MAW}
\newfontlanguage{Mbundu}{MBN}\newfontlanguage{Manchu}{MCH}
\newfontlanguage{Moose~Cree}{MCR}\newfontlanguage{Mende}{MDE}
\newfontlanguage{Me'en}{MEN}\newfontlanguage{Mizo}{MIZ}
\newfontlanguage{Macedonian}{MKD}\newfontlanguage{Male}{MLE}
\newfontlanguage{Malagasy}{MLG}\newfontlanguage{Malinke}{MLN}
\newfontlanguage{Malayalam~Reformed}{MLR}\newfontlanguage{Malay}{MLY}
\newfontlanguage{Mandinka}{MND}\newfontlanguage{Mongolian}{MNG}
\newfontlanguage{Manipuri}{MNI}\newfontlanguage{Maninka}{MNK}
\newfontlanguage{Manx~Gaelic}{MNX}\newfontlanguage{Moksha}{MOK}
\newfontlanguage{Moldavian}{MOL}\newfontlanguage{Mon}{MON}
\newfontlanguage{Moroccan}{MOR}\newfontlanguage{Maori}{MRI}
\newfontlanguage{Maithili}{MTH}\newfontlanguage{Maltese}{MTS}
\newfontlanguage{Mundari}{MUN}\newfontlanguage{Naga-Assamese}{NAG}
\newfontlanguage{Nanai}{NAN}\newfontlanguage{Naskapi}{NAS}
\newfontlanguage{N-Cree}{NCR}\newfontlanguage{Ndebele}{NDB}
\newfontlanguage{Ndonga}{NDG}\newfontlanguage{Nepali}{NEP}
\newfontlanguage{Newari}{NEW}\newfontlanguage{Nagari}{NGR}
\newfontlanguage{Norway~House~Cree}{NHC}\newfontlanguage{Nisi}{NIS}
\newfontlanguage{Niuean}{NIU}\newfontlanguage{Nkole}{NKL}
\newfontlanguage{N'ko}{NKO}\newfontlanguage{Dutch}{NLD}
\newfontlanguage{Nogai}{NOG}\newfontlanguage{Norwegian}{NOR}
\newfontlanguage{Northern~Sami}{NSM}\newfontlanguage{Northern~Tai}{NTA}
\newfontlanguage{Esperanto}{NTO}\newfontlanguage{Nynorsk}{NYN}
\newfontlanguage{Oji-Cree}{OCR}\newfontlanguage{Ojibway}{OJB}
\newfontlanguage{Oriya}{ORI}\newfontlanguage{Oromo}{ORO}
\newfontlanguage{Ossetian}{OSS}\newfontlanguage{Palestinian~Aramaic}{PAA}
\newfontlanguage{Pali}{PAL}\newfontlanguage{Punjabi}{PAN}
\newfontlanguage{Palpa}{PAP}\newfontlanguage{Pashto}{PAS}
\newfontlanguage{Polytonic~Greek}{PGR}\newfontlanguage{Pilipino}{PIL}
\newfontlanguage{Palaung}{PLG}\newfontlanguage{Polish}{PLK}
\newfontlanguage{Provencal}{PRO}\newfontlanguage{Portuguese}{PTG}
\newfontlanguage{Chin}{QIN}\newfontlanguage{Rajasthani}{RAJ}
\newfontlanguage{R-Cree}{RCR}\newfontlanguage{Russian~Buriat}{RBU}
\newfontlanguage{Riang}{RIA}\newfontlanguage{Rhaeto-Romanic}{RMS}
\newfontlanguage{Romanian}{ROM}\newfontlanguage{Romany}{ROY}
\newfontlanguage{Rusyn}{RSY}\newfontlanguage{Ruanda}{RUA}
\newfontlanguage{Russian}{RUS}\newfontlanguage{Sadri}{SAD}
\newfontlanguage{Sanskrit}{SAN}\newfontlanguage{Santali}{SAT}
\newfontlanguage{Sayisi}{SAY}\newfontlanguage{Sekota}{SEK}
\newfontlanguage{Selkup}{SEL}\newfontlanguage{Sango}{SGO}
\newfontlanguage{Shan}{SHN}\newfontlanguage{Sibe}{SIB}
\newfontlanguage{Sidamo}{SID}\newfontlanguage{Silte~Gurage}{SIG}
\newfontlanguage{Skolt~Sami}{SKS}\newfontlanguage{Slovak}{SKY}
\newfontlanguage{Slavey}{SLA}\newfontlanguage{Slovenian}{SLV}
\newfontlanguage{Somali}{SML}\newfontlanguage{Samoan}{SMO}
\newfontlanguage{Sena}{SNA}\newfontlanguage{Sindhi}{SND}
\newfontlanguage{Sinhalese}{SNH}\newfontlanguage{Soninke}{SNK}
\newfontlanguage{Sodo~Gurage}{SOG}\newfontlanguage{Sotho}{SOT}
\newfontlanguage{Albanian}{SQI}\newfontlanguage{Serbian}{SRB}
\newfontlanguage{Saraiki}{SRK}\newfontlanguage{Serer}{SRR}
\newfontlanguage{South~Slavey}{SSL}\newfontlanguage{Southern~Sami}{SSM}
\newfontlanguage{Suri}{SUR}\newfontlanguage{Svan}{SVA}
\newfontlanguage{Swedish}{SVE}\newfontlanguage{Swadaya~Aramaic}{SWA}
\newfontlanguage{Swahili}{SWK}\newfontlanguage{Swazi}{SWZ}
\newfontlanguage{Sutu}{SXT}\newfontlanguage{Syriac}{SYR}
\newfontlanguage{Tabasaran}{TAB}\newfontlanguage{Tajiki}{TAJ}
\newfontlanguage{Tamil}{TAM}\newfontlanguage{Tatar}{TAT}
\newfontlanguage{TH-Cree}{TCR}\newfontlanguage{Telugu}{TEL}
\newfontlanguage{Tongan}{TGN}\newfontlanguage{Tigre}{TGR}
\newfontlanguage{Tigrinya}{TGY}\newfontlanguage{Thai}{THA}
\newfontlanguage{Tahitian}{THT}\newfontlanguage{Tibetan}{TIB}
\newfontlanguage{Turkmen}{TKM}\newfontlanguage{Temne}{TMN}
\newfontlanguage{Tswana}{TNA}\newfontlanguage{Tundra~Nenets}{TNE}
\newfontlanguage{Tonga}{TNG}\newfontlanguage{Todo}{TOD}
\newfontlanguage{Tsonga}{TSG}\newfontlanguage{Turoyo~Aramaic}{TUA}
\newfontlanguage{Tulu}{TUL}\newfontlanguage{Tuvin}{TUV}
\newfontlanguage{Twi}{TWI}\newfontlanguage{Udmurt}{UDM}
\newfontlanguage{Ukrainian}{UKR}\newfontlanguage{Urdu}{URD}
\newfontlanguage{Upper~Sorbian}{USB}\newfontlanguage{Uyghur}{UYG}
\newfontlanguage{Uzbek}{UZB}\newfontlanguage{Venda}{VEN}
\newfontlanguage{Vietnamese}{VIT}\newfontlanguage{Wa}{WA}
\newfontlanguage{Wagdi}{WAG}\newfontlanguage{West-Cree}{WCR}
\newfontlanguage{Welsh}{WEL}\newfontlanguage{Wolof}{WLF}
\newfontlanguage{Tai~Lue}{XBD}\newfontlanguage{Xhosa}{XHS}
\newfontlanguage{Yakut}{YAK}\newfontlanguage{Yoruba}{YBA}
\newfontlanguage{Y-Cree}{YCR}\newfontlanguage{Yi~Classic}{YIC}
\newfontlanguage{Yi~Modern}{YIM}\newfontlanguage{Chinese~Hong~Kong}{ZHH}
\newfontlanguage{Chinese~Phonetic}{ZHP}
\newfontlanguage{Chinese~Simplified}{ZHS}
\newfontlanguage{Chinese~Traditional}{ZHT}\newfontlanguage{Zande}{ZND}
\newfontlanguage{Zulu}{ZUL}
%    \end{macrocode}
%
% \paragraph{Turkish} Turns out that many fonts use `TUR' as their Turkish language tag rather than the specified `TRK'. So we check for both:
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  Language / Turkish .code:n =
   {
    \fontspec_check_lang:nTF {TRK}
     {
      \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
      \tl_set:Nn \l_fontspec_lang_tl {TRK}
     }
     {
      \fontspec_check_lang:nTF {TUR}
       {
        \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
        \tl_set:Nn \l_fontspec_lang_tl {TUR}
       }
       {
        \@@_warning:nx {language-not-exist} {Turkish}
        \keys_set:nn {fontspec} {Language=Default}
       }
     }
   }
 }
%    \end{macrocode}
%
% \paragraph{Default}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec}{ Language / Default }
 {
  \tl_set:Nn \l_fontspec_lang_tl {DFLT}
  \int_zero:N \l_fontspec_language_int
 }
%    \end{macrocode}
%
% \subsubsection{Raw feature string}
% This allows savvy \XeTeX-ers to input font features manually if they have
% already memorised the OpenType abbreviations and don't mind not having error checking.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {RawFeature}
 {
  \@@_update_featstr:n {#1}
 }
%    \end{macrocode}
%
%
%
% \subsection{Italic small caps} \label{sec:sishape}
% The following code for utilising italic small caps sensibly is
% inspired from Philip Lehman's \textit{The Font Installation
%   Guide}. Note that |\upshape| needs to be used \emph{twice} to get
% from italic small caps to regular upright (it always goes to small
% caps, then regular upright).
% \begin{macro}{\sishape}
% \begin{macro}{\textsi}
%     First, the commands for actually selecting italic small caps are
%     defined. I use |si| as the NFSS shape for italic small caps, but
%     I have seen |itsc| and |slsc| also used. |\sidefault| may be
%     redefined to one of these if required for compatibility.
%    \begin{macrocode}
\providecommand*{\sidefault}{si}
\DeclareRobustCommand{\sishape}
 {
  \not@math@alphabet\sishape\relax
  \fontshape\sidefault\selectfont
 }
\DeclareTextFontCommand{\textsi}{\sishape}
%    \end{macrocode}
% \end{macro} \end{macro}
% \begin{macro}{\fontspec_blend_shape:nnn}
%   This is the macro which enables the overload on the |\..shape|
%   commands. It takes three such arguments. In essence, the macro
%   selects the first argument, unless the second argument is already
%   selected, in which case it selects the third.
%    \begin{macrocode}
\cs_new:Nn \fontspec_blend_shape:nnn
 {
  \bool_if:nTF
   {
    \str_if_eq_x_p:nn {\f@shape} {#2} &&
    \cs_if_exist_p:c {\f@encoding/\f@family/\f@series/#3}
   }
   { \fontshape{#3}\selectfont }
   { \fontshape{#1}\selectfont }
 }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\itshape} \begin{macro}{\scshape} \begin{macro}{\upshape}
%       Here the original |\..shape| commands are redefined to use the
%       merge shape macro.
%    \begin{macrocode}
\DeclareRobustCommand \itshape
 {
  \not@math@alphabet\itshape\mathit
  \fontspec_blend_shape:nnn\itdefault\scdefault\sidefault
 }
\DeclareRobustCommand \slshape
 {
  \not@math@alphabet\slshape\relax
  \fontspec_blend_shape:nnn\sldefault\scdefault\sidefault
 }
\DeclareRobustCommand \scshape
 {
  \not@math@alphabet\scshape\relax
  \fontspec_blend_shape:nnn\scdefault\itdefault\sidefault
 }
\DeclareRobustCommand \upshape
 {
  \not@math@alphabet\upshape\relax
  \fontspec_blend_shape:nnn\updefault\sidefault\scdefault
 }
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
%
% \subsection{Selecting maths fonts}
% Here, the fonts used in math mode are redefined to correspond to the
% default roman, sans serif and typewriter fonts. Unfortunately, you
% can only define maths fonts in the preamble, otherwise I'd run this
% code whenever \cs{setmainfont} and friends was run.
%
% \begin{macro}{\fontspec_setup_maths:}
% Everything here is performed \cs{AtBeginDocument} in order to
% overwrite \pkg{euler}'s attempt. This means \pkg{fontspec} must be
% loaded \emph{after} \pkg{euler}. We set up a conditional to return
% an error if this rule is violated.
%
% Since every maths setup is slightly different, we also take
% different paths for defining various math glyphs depending which
% maths font package has been loaded.
%
%    \begin{macrocode}
\@ifpackageloaded{euler}
 {
  \bool_set_true:N \g_@@_pkg_euler_loaded_bool
 }
 {
  \bool_set_false:N \g_@@_pkg_euler_loaded_bool
 }
\cs_set:Nn \fontspec_setup_maths:
 {
  \@ifpackageloaded{euler}
   {
    \bool_if:NTF \g_@@_pkg_euler_loaded_bool
     { \bool_set_true:N \g_@@_math_euler_bool }
     { \@@_error:n {euler-too-late} }
   }
   {}
  \@ifpackageloaded{lucbmath}{\bool_set_true:N \g_@@_math_lucida_bool}{}
  \@ifpackageloaded{lucidabr}{\bool_set_true:N \g_@@_math_lucida_bool}{}
  \@ifpackageloaded{lucimatx}{\bool_set_true:N \g_@@_math_lucida_bool}{}
%    \end{macrocode}
% Knuth's CM fonts fonts are all squashed together, combining letters,
% accents, text symbols and maths symbols all in the one font,
% \texttt{cmr}, plus other things in other fonts. Because we are
% changing the roman font in the document, we need to redefine all of
% the maths glyphs in \LaTeX's \texttt{operators} maths font to still
% go back to the legacy \texttt{cmr} font for all these random glyphs,
% unless a separate maths font package has been loaded instead.
%
% In every case, the maths accents are always taken from the
% \texttt{operators} font, which is generally the main text
% font. (Actually, there is a \cmd\hat\ accent in
% \texttt{EulerFractur}, but it's \emph{ugly}. So I ignore it. Sorry
% if this causes inconvenience.)
%    \begin{macrocode}
  \DeclareSymbolFont{legacymaths}{OT1}{cmr}{m}{n}
  \SetSymbolFont{legacymaths}{bold}{OT1}{cmr}{bx}{n}
  \DeclareMathAccent{\acute}   {\mathalpha}{legacymaths}{19}
  \DeclareMathAccent{\grave}   {\mathalpha}{legacymaths}{18}
  \DeclareMathAccent{\ddot}    {\mathalpha}{legacymaths}{127}
  \DeclareMathAccent{\tilde}   {\mathalpha}{legacymaths}{126}
  \DeclareMathAccent{\bar}     {\mathalpha}{legacymaths}{22}
  \DeclareMathAccent{\breve}   {\mathalpha}{legacymaths}{21}
  \DeclareMathAccent{\check}   {\mathalpha}{legacymaths}{20}
  \DeclareMathAccent{\hat}     {\mathalpha}{legacymaths}{94} % too bad, euler
  \DeclareMathAccent{\dot}     {\mathalpha}{legacymaths}{95}
  \DeclareMathAccent{\mathring}{\mathalpha}{legacymaths}{23}
%    \end{macrocode}
% \paragraph{\cmd\colon: what's going on?} Okay, so \verb":" and \cmd\colon\ in maths mode are defined in a few places, so I need to work out what does what. Respectively, we have:
% \begin{Verbatim}
% % fontmath.ltx:
% \DeclareMathSymbol{\colon}{\mathpunct}{operators}{"3A}
% \DeclareMathSymbol{:}{\mathrel}{operators}{"3A}
%
% % amsmath.sty:
% \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
%  \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}
%
% % euler.sty:
% \DeclareMathSymbol{:}\mathrel  {EulerFraktur}{"3A}
%
% % lucbmath.sty:
% \DeclareMathSymbol{\@tempb}{\mathpunct}{operators}{58}
% \ifx\colon\@tempb
%   \DeclareMathSymbol{\colon}{\mathpunct}{operators}{58}
% \fi
% \DeclareMathSymbol{:}{\mathrel}{operators}{58}
% \end{Verbatim}
% ($\mathrm{3A_{16}}=\mathrm{58_{10}}$) So I think, based on this summary, that it is fair to tell \pkg{fontspec} to `replace' the operators font with legacymaths for this symbol, except when \pkg{amsmath} is loaded since we want to keep its definition.
%
%
%    \begin{macrocode}
  \group_begin:
    \mathchardef\@tempa="603A \relax
    \ifx\colon\@tempa
      \DeclareMathSymbol{\colon}{\mathpunct}{legacymaths}{58}
    \fi
  \group_end:
%    \end{macrocode}
% The following symbols are only defined specifically in \pkg{euler}, so skip them
% if that package is loaded.
%    \begin{macrocode}
  \bool_if:NF \g_@@_math_euler_bool
   {
    \DeclareMathSymbol{!}{\mathclose}{legacymaths}{33}
    \DeclareMathSymbol{:}{\mathrel}  {legacymaths}{58}
    \DeclareMathSymbol{;}{\mathpunct}{legacymaths}{59}
    \DeclareMathSymbol{?}{\mathclose}{legacymaths}{63}
%    \end{macrocode}
% And these ones are defined both in \pkg{euler} and \pkg{lucbmath},
% so we only need to run this code if no extra maths package has been
% loaded.
%    \begin{macrocode}
    \bool_if:NF \g_@@_math_lucida_bool
     {
      \DeclareMathSymbol{0}{\mathalpha}{legacymaths}{`0}
      \DeclareMathSymbol{1}{\mathalpha}{legacymaths}{`1}
      \DeclareMathSymbol{2}{\mathalpha}{legacymaths}{`2}
      \DeclareMathSymbol{3}{\mathalpha}{legacymaths}{`3}
      \DeclareMathSymbol{4}{\mathalpha}{legacymaths}{`4}
      \DeclareMathSymbol{5}{\mathalpha}{legacymaths}{`5}
      \DeclareMathSymbol{6}{\mathalpha}{legacymaths}{`6}
      \DeclareMathSymbol{7}{\mathalpha}{legacymaths}{`7}
      \DeclareMathSymbol{8}{\mathalpha}{legacymaths}{`8}
      \DeclareMathSymbol{9}{\mathalpha}{legacymaths}{`9}
      \DeclareMathSymbol{\Gamma}{\mathalpha}{legacymaths}{0}
      \DeclareMathSymbol{\Delta}{\mathalpha}{legacymaths}{1}
      \DeclareMathSymbol{\Theta}{\mathalpha}{legacymaths}{2}
      \DeclareMathSymbol{\Lambda}{\mathalpha}{legacymaths}{3}
      \DeclareMathSymbol{\Xi}{\mathalpha}{legacymaths}{4}
      \DeclareMathSymbol{\Pi}{\mathalpha}{legacymaths}{5}
      \DeclareMathSymbol{\Sigma}{\mathalpha}{legacymaths}{6}
      \DeclareMathSymbol{\Upsilon}{\mathalpha}{legacymaths}{7}
      \DeclareMathSymbol{\Phi}{\mathalpha}{legacymaths}{8}
      \DeclareMathSymbol{\Psi}{\mathalpha}{legacymaths}{9}
      \DeclareMathSymbol{\Omega}{\mathalpha}{legacymaths}{10}
      \DeclareMathSymbol{+}{\mathbin}{legacymaths}{43}
      \DeclareMathSymbol{=}{\mathrel}{legacymaths}{61}
      \DeclareMathDelimiter{(}{\mathopen} {legacymaths}{40}{largesymbols}{0}
      \DeclareMathDelimiter{)}{\mathclose}{legacymaths}{41}{largesymbols}{1}
      \DeclareMathDelimiter{[}{\mathopen} {legacymaths}{91}{largesymbols}{2}
      \DeclareMathDelimiter{]}{\mathclose}{legacymaths}{93}{largesymbols}{3}
      \DeclareMathDelimiter{/}{\mathord}{legacymaths}{47}{largesymbols}{14}
      \DeclareMathSymbol{\mathdollar}{\mathord}{legacymaths}{36}
    }
  }
%    \end{macrocode}
% Finally, we change the font definitions for \cmd\mathrm\ and so
% on. These are defined using the \cmd\g_@@_mathrm_tl\ (\dots) macros,
% which default to \cmd\rmdefault\ but may be specified with the
% \cmd\setmathrm\ (\dots) commands in the preamble.
%
% Since \LaTeX\ only generally defines one level of boldness, we omit
% \cmd\mathbf\ in the \textsf{bold} maths series. It can be specified
% as per usual with \cmd\setboldmathrm, which stores the appropriate
% family name in \cmd\g_@@_bfmathrm_tl.
%    \begin{macrocode}
  \DeclareSymbolFont{operators}\g_fontspec_encoding_tl\g_@@_mathrm_tl\mddefault\updefault
  \SetSymbolFont{operators}{normal}\g_fontspec_encoding_tl\g_@@_mathrm_tl\mddefault\updefault
  \DeclareSymbolFontAlphabet\mathrm{operators}
  \SetMathAlphabet\mathit{normal}\g_fontspec_encoding_tl\g_@@_mathrm_tl\mddefault\itdefault
  \SetMathAlphabet\mathbf{normal}\g_fontspec_encoding_tl\g_@@_mathrm_tl\bfdefault\updefault
  \SetMathAlphabet\mathsf{normal}\g_fontspec_encoding_tl\g_@@_mathsf_tl\mddefault\updefault
  \SetMathAlphabet\mathtt{normal}\g_fontspec_encoding_tl\g_@@_mathtt_tl\mddefault\updefault
  \SetSymbolFont{operators}{bold}\g_fontspec_encoding_tl\g_@@_mathrm_tl\bfdefault\updefault
  \tl_if_empty:NTF \g_@@_bfmathrm_tl
   {
    \SetMathAlphabet\mathit{bold}\g_fontspec_encoding_tl\g_@@_mathrm_tl\bfdefault\itdefault
   }
   {
    \SetMathAlphabet\mathrm{bold}\g_fontspec_encoding_tl\g_@@_bfmathrm_tl\mddefault\updefault
    \SetMathAlphabet\mathbf{bold}\g_fontspec_encoding_tl\g_@@_bfmathrm_tl\bfdefault\updefault
    \SetMathAlphabet\mathit{bold}\g_fontspec_encoding_tl\g_@@_bfmathrm_tl\mddefault\itdefault
   }
  \SetMathAlphabet\mathsf{bold}\g_fontspec_encoding_tl\g_@@_mathsf_tl\bfdefault\updefault
  \SetMathAlphabet\mathtt{bold}\g_fontspec_encoding_tl\g_@@_mathtt_tl\bfdefault\updefault
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_maybe_setup_maths:}
% We're a little less sophisticated about not executing the maths setup if various other maths font packages are loaded. This list is based on the wonderful `\LaTeX Font Catalogue': \url{http://www.tug.dk/FontCatalogue/mathfonts.html}. I'm sure there are more I've missed. Do the \TeX\ Gyre fonts have maths support yet?
%
% Untested: would |\unless\ifnum\Gamma=28672\relax\bool_set_false:N \g_@@_math_bool\fi| be a better test?
% This needs more cooperation with euler and lucida, I think.
%    \begin{macrocode}
\cs_new:Nn \fontspec_maybe_setup_maths:
 {
  \@ifpackageloaded{anttor}
   {
    \ifx\define@antt@mathversions a\bool_set_false:N \g_@@_math_bool\fi
   }{}
  \@ifpackageloaded{arev}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{eulervm}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{mathdesign}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{concmath}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{cmbright}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{mathesf}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{gfsartemisia}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{gfsneohellenic}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{iwona}
   {
    \ifx\define@iwona@mathversions a\bool_set_false:N \g_@@_math_bool\fi
   }{}
  \@ifpackageloaded{kpfonts}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{kmath}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{kurier}
   {
    \ifx\define@kurier@mathversions a\bool_set_false:N \g_@@_math_bool\fi
   }{}
  \@ifpackageloaded{fouriernc}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{fourier}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{lmodern}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{mathpazo}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{mathptmx}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{MinionPro}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{unicode-math}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{breqn}{\bool_set_false:N \g_@@_math_bool}{}
  \bool_if:NT \g_@@_math_bool
   {
    \@@_info:n {setup-math}
    \fontspec_setup_maths:
   }
 }
\AtBeginDocument{\fontspec_maybe_setup_maths:}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Finishing up}
% Now we just want to set up loading the \texttt{.cfg} file, if it exists.
%    \begin{macrocode}
\bool_if:NT \g_@@_cfg_bool
 {
  \InputIfFileExists{fontspec.cfg}
    {}
    {\typeout{No~ fontspec.cfg~ file~ found;~ no~ configuration~ loaded.}}
 }
%    \end{macrocode}
%
% \subsection{Compatibility}
%
% \begin{macro}{\zf@enc}
% \begin{macro}{\zf@family}
% \begin{macro}{\zf@basefont}
% \begin{macro}{\zf@fontspec}
% Old interfaces.
% These are needed by, at least, the \pkg{mathspec} package.
%    \begin{macrocode}
\tl_set:Nn \zf@enc { \g_fontspec_encoding_tl }
\cs_set:Npn \zf@fontspec #1 #2
 {
  \fontspec_select:nn {#1} {#2}
  \tl_set:Nn \zf@family { \l_fontspec_family_tl }
  \tl_set:Nn \zf@basefont { \l_fontspec_font }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% The end! Thanks for coming.
%    \begin{macrocode}
\ExplSyntaxOff
%</fontspec&(xetexx|luatex)>
%    \end{macrocode}
